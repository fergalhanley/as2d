{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","~lib/rt/pure.ts","~lib/rt/tlsf.ts","~lib/gc.ts","~lib/rt.ts","~lib/util/error.ts","~lib/memory.ts","~lib/util/memory.ts","src/shared/CanvasInstruction.ts","src/shared/CanvasDirection.ts","src/shared/CanvasPatternRepetition.ts","src/shared/GlobalCompositeOperation.ts","src/shared/ImageSmoothingQuality.ts","src/shared/LineCap.ts","src/shared/LineJoin.ts","src/shared/TextAlign.ts","src/shared/TextBaseline.ts","src/shared/FillRule.ts","assembly/internal/FillStrokeStyleType.ts","assembly/renderer/CanvasRenderingContext2D.ts","~lib/arraybuffer.ts","~lib/util/number.ts","~lib/util/string.ts","~lib/typedarray.ts","~lib/map.ts","~lib/util/hash.ts","assembly/internal/getContext.ts","assembly/internal/Buffer.ts","assembly/internal/StackPointer.ts","assembly/internal/util.ts","~lib/string.ts","assembly/renderer/Image.ts","assembly/draw-functions.test.ts","assembly/renderer/CanvasGradient.ts","assembly/renderer/CanvasPattern.ts","~lib/builtins.ts","~lib/math.ts","~lib/array.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                           GC info                             │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                          runtime id                           │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                         runtime size                          │ -4\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                              ...                              │ ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags;\n  /** Base class id or `0` if none. */\n  base: u32;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `Set`. */\n  SET = 1 << 2,\n  /** Type is a `Map`. */\n  MAP = 1 << 3,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 4,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 5,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 6,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 7,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 8,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 9,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 10,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 11,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 12,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 13,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 14,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 15,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 16,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 17,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 18,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 19,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 20,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 21,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 22\n}\n","import { DEBUG, BLOCK_OVERHEAD } from \"rt/common\";\nimport { Block, freeBlock, ROOT } from \"rt/tlsf\";\nimport { TypeinfoFlags } from \"shared/typeinfo\";\nimport { onincrement, ondecrement, onfree, onalloc } from \"./rtrace\";\n\n/////////////////////////// A Pure Reference Counting Garbage Collector ///////////////////////////\n// see:     https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon03Pure.pdf\n\n// ╒══════════════════════ GC Info structure ══════════════════════╕\n// │  3                   2                   1                    │\n// │1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0│\n// ├─┼─┴─┴─┼─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │B│color│                     refCount                          │\n// └─┴─────┴───────────────────────────────────────────────────────┘\n// B: buffered\n\n// @ts-ignore: decorator\n@inline const BUFFERED_MASK: u32 = 1 << ((sizeof<u32>() * 8) - 1);\n// @ts-ignore: decorator\n@inline const COLOR_BITS = 3;\n// @ts-ignore: decorator\n@inline const COLOR_SHIFT: u32 = ctz(BUFFERED_MASK) - COLOR_BITS;\n// @ts-ignore: decorator\n@inline const COLOR_MASK: u32 = ((1 << COLOR_BITS) - 1) << COLOR_SHIFT;\n// @ts-ignore: decorator\n@inline export const REFCOUNT_MASK: u32 = (1 << COLOR_SHIFT) - 1;\n\n// ╒════════╤═══════════════════ Colors ═══════════════════════════╕\n// │ Color  │ Meaning                                              │\n// ├────────┼──────────────────────────────────────────────────────┤\n// │ BLACK  │ In use or free                                       │\n// │ GRAY   │ Possible member of cycle                             │\n// │ WHITE  │ Member of garbage cycle                              │\n// │ PURPLE │ Possible root of cycle                               │\n// │ RED    │ Candidate cycle undergoing Σ-computation *concurrent │\n// │ ORANGE │ Candidate cycle awaiting epoch boundary  *concurrent │\n// └────────┴──────────────────────────────────────────────────────┘\n// Acyclic detection has been decoupled, hence no GREEN.\n\n// @ts-ignore: decorator\n@inline const COLOR_BLACK: u32 = 0 << COLOR_SHIFT;\n// @ts-ignore: decorator\n@inline const COLOR_GRAY: u32 = 1 << COLOR_SHIFT;\n// @ts-ignore: decorator\n@inline const COLOR_WHITE: u32 = 2 << COLOR_SHIFT;\n// @ts-ignore: decorator\n@inline const COLOR_PURPLE: u32 = 3 << COLOR_SHIFT;\n// @ts-ignore: decorator\n// @inline const COLOR_RED: u32 = 4 << COLOR_SHIFT;\n// @ts-ignore: decorator\n// @inline const COLOR_ORANGE: u32 = 5 << COLOR_SHIFT;\n\n// @ts-ignore: decorator\n@inline const VISIT_DECREMENT = 1; // guard 0\n// @ts-ignore: decorator\n@inline const VISIT_MARKGRAY = 2;\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 3;\n// @ts-ignore: decorator\n@inline const VISIT_SCANBLACK = 4;\n// @ts-ignore: decorator\n@inline const VISIT_COLLECTWHITE = 5;\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __visit(ref: usize, cookie: i32): void {\n  if (ref < __heap_base) return;\n  var s = changetype<Block>(ref - BLOCK_OVERHEAD);\n  switch (cookie) {\n    case VISIT_DECREMENT: {\n      decrement(s);\n      break;\n    }\n    case VISIT_MARKGRAY: {\n      if (DEBUG) assert((s.gcInfo & REFCOUNT_MASK) > 0);\n      s.gcInfo = s.gcInfo - 1;\n      markGray(s);\n      break;\n    }\n    case VISIT_SCAN: {\n      scan(s);\n      break;\n    }\n    case VISIT_SCANBLACK: {\n      let info = s.gcInfo;\n      assert((info & ~REFCOUNT_MASK) == ((info + 1) & ~REFCOUNT_MASK)); // overflow\n      s.gcInfo = info + 1;\n      if ((info & COLOR_MASK) != COLOR_BLACK) {\n        scanBlack(s);\n      }\n      break;\n    }\n    case VISIT_COLLECTWHITE: {\n      collectWhite(s);\n      break;\n    }\n    default: if (DEBUG) assert(false);\n  }\n}\n\n/** Increments the reference count of the specified block by one.*/\nfunction increment(s: Block): void {\n  var info = s.gcInfo;\n  assert((info & ~REFCOUNT_MASK) == ((info + 1) & ~REFCOUNT_MASK)); // overflow\n  s.gcInfo = info + 1;\n  if (isDefined(ASC_RTRACE)) onincrement(s);\n  if (DEBUG) assert(!(s.mmInfo & 1)); // used\n}\n\n/** Decrements the reference count of the specified block by one, possibly freeing it. */\nfunction decrement(s: Block): void {\n  var info = s.gcInfo;\n  var rc = info & REFCOUNT_MASK;\n  if (isDefined(ASC_RTRACE)) ondecrement(s);\n  if (DEBUG) assert(!(s.mmInfo & 1)); // used\n  if (rc == 1) {\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_DECREMENT);\n    if (!(info & BUFFERED_MASK)) {\n      freeBlock(ROOT, s);\n    } else {\n      s.gcInfo = BUFFERED_MASK | COLOR_BLACK | 0;\n    }\n  } else {\n    if (DEBUG) assert(rc > 0);\n    if (!(__typeinfo(s.rtId) & TypeinfoFlags.ACYCLIC)) {\n      s.gcInfo = BUFFERED_MASK | COLOR_PURPLE | (rc - 1);\n      if (!(info & BUFFERED_MASK)) {\n        appendRoot(s);\n      }\n    } else {\n      s.gcInfo = (info & ~REFCOUNT_MASK) | (rc - 1);\n    }\n  }\n}\n\n/** Buffer of possible roots. */\n// @ts-ignore: decorator\n@lazy var ROOTS: usize;\n/** Current absolute offset into the `ROOTS` buffer. */\n// @ts-ignore: decorator\n@lazy var CUR: usize = 0;\n/** Current absolute end offset into the `ROOTS` buffer. */\n// @ts-ignore: decorator\n@lazy var END: usize = 0;\n\n/** Appends a block to possible roots. */\nfunction appendRoot(s: Block): void {\n  var cur = CUR;\n  if (cur >= END) {\n    growRoots(); // TBD: either that or pick a default and force collection on overflow\n    cur = CUR;\n  }\n  store<Block>(cur, s);\n  CUR = cur + sizeof<usize>();\n}\n\n/** Grows the roots buffer if it ran full. */\nfunction growRoots(): void {\n  var oldRoots = ROOTS;\n  var oldSize = CUR - oldRoots;\n  var newSize = max(oldSize * 2, 64 << alignof<usize>());\n  var newRoots = __alloc(newSize, 0);\n  if (isDefined(ASC_RTRACE)) onfree(changetype<Block>(newRoots - BLOCK_OVERHEAD)); // neglect unmanaged\n  memory.copy(newRoots, oldRoots, oldSize);\n  if (oldRoots) {\n    if (isDefined(ASC_RTRACE)) onalloc(changetype<Block>(oldRoots - BLOCK_OVERHEAD)); // neglect unmanaged\n    __free(oldRoots);\n  }\n  ROOTS = newRoots;\n  CUR = newRoots + oldSize;\n  END = newRoots + newSize;\n}\n\n/** Collects cyclic garbage. */\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n\n  // markRoots\n  var roots = ROOTS;\n  var cur = roots;\n  for (let pos = cur, end = CUR; pos < end; pos += sizeof<usize>()) {\n    let s = load<Block>(pos);\n    let info = s.gcInfo;\n    if ((info & COLOR_MASK) == COLOR_PURPLE && (info & REFCOUNT_MASK) > 0) {\n      markGray(s);\n      store<Block>(cur, s);\n      cur += sizeof<usize>();\n    } else {\n      if ((info & COLOR_MASK) == COLOR_BLACK && !(info & REFCOUNT_MASK)) {\n        freeBlock(ROOT, s);\n      } else {\n        s.gcInfo = info & ~BUFFERED_MASK;\n      }\n    }\n  }\n  CUR = cur;\n\n  // scanRoots\n  for (let pos = roots; pos < cur; pos += sizeof<usize>()) {\n    scan(load<Block>(pos));\n  }\n\n  // collectRoots\n  for (let pos = roots; pos < cur; pos += sizeof<usize>()) {\n    let s = load<Block>(pos);\n    s.gcInfo = s.gcInfo & ~BUFFERED_MASK;\n    collectWhite(s);\n  }\n  CUR = roots;\n}\n\n/** Marks a block as gray (possible member of cycle) during the collection phase. */\nfunction markGray(s: Block): void {\n  var info = s.gcInfo;\n  if ((info & COLOR_MASK) != COLOR_GRAY) {\n    s.gcInfo = (info & ~COLOR_MASK) | COLOR_GRAY;\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_MARKGRAY);\n  }\n}\n\n/** Scans a block during the collection phase, determining whether it is garbage or not. */\nfunction scan(s: Block): void {\n  var info = s.gcInfo;\n  if ((info & COLOR_MASK) == COLOR_GRAY) {\n    if ((info & REFCOUNT_MASK) > 0) {\n      scanBlack(s);\n    } else {\n      s.gcInfo = (info & ~COLOR_MASK) | COLOR_WHITE;\n      __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_SCAN);\n    }\n  }\n}\n\n/** Marks a block as black (in use) if it was found to be reachable during the collection phase. */\nfunction scanBlack(s: Block): void {\n  s.gcInfo = (s.gcInfo & ~COLOR_MASK) | COLOR_BLACK;\n  __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_SCANBLACK);\n}\n\n/** Collects all white (member of a garbage cycle) nodes when completing the collection phase.  */\nfunction collectWhite(s: Block): void {\n  var info = s.gcInfo;\n  if ((info & COLOR_MASK) == COLOR_WHITE && !(info & BUFFERED_MASK)) {\n    s.gcInfo = (info & ~COLOR_MASK) | COLOR_BLACK;\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_COLLECTWHITE);\n    freeBlock(ROOT, s);\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __retain(ref: usize): usize {\n  if (ref > __heap_base) increment(changetype<Block>(ref - BLOCK_OVERHEAD));\n  return ref;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __release(ref: usize): void {\n  if (ref > __heap_base) decrement(changetype<Block>(ref - BLOCK_OVERHEAD));\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __reset(): void {\n}\n","import { AL_BITS, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"rt/common\";\nimport { onfree, onalloc } from \"./rtrace\";\nimport { REFCOUNT_MASK } from \"./pure\";\n\n/////////////////////// The TLSF (Two-Level Segregate Fit) memory allocator ///////////////////////\n//                             see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴───────╨───────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: usize = 1 << <usize>SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: usize = <usize>(SL_BITS + AL_BITS);\n// @ts-ignore: decorator\n@inline const SB_SIZE: usize = 1 << <usize>SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┼─┤ overhead   ┐\n// │                          size                           │0│L│F│ ◄─┐ info\n// ├─────────────────────────────────────────────────────────┴─┴─┴─┤   │\n// │                                                               │   │\n// │               ... additional runtime overhead ...             │   │\n// │                                                               │   │\n// ╞═══════════════════════════════════════════════════════════════╡   │      ┐ ┘\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                             ...                               │   │    = 0\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: back ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ payload  ┘ >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = (3 * sizeof<usize>() + AL_MASK) & ~AL_MASK; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                           slMap[22]                           │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[367]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                             tail                              │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export var ROOT: Root;\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    let newSize = (blockInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (newSize < BLOCK_MAXSIZE) {\n      removeBlock(root, right);\n      block.mmInfo = blockInfo = (blockInfo & TAGS_MASK) | newSize;\n      right = GETRIGHT(block);\n      rightInfo = right.mmInfo;\n      // 'back' is set below\n    }\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    let newSize = (leftInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK);\n    if (newSize < BLOCK_MAXSIZE) {\n      removeBlock(root, left);\n      left.mmInfo = blockInfo = (leftInfo & TAGS_MASK) | newSize;\n      block = left;\n      // 'back' is set below\n    }\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    fl = inv - clz<usize>(size);\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  var head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be valid\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    fl = inv - clz<usize>(size);\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  var prev = block.prev;\n  var next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    const invRound = inv - SL_BITS;\n    let requestSize = size < halfMaxSize\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\n      : size;\n    fl = inv - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  var slMap = GETSL(root, fl) & (~0 << sl);\n  var head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(!(size & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  var remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, end: usize): bool {\n  if (DEBUG) {\n    assert(\n      start <= end &&       // must be valid\n      !(start & AL_MASK) && // must be aligned\n      !(end & AL_MASK)      // must be aligned\n    );\n  }\n\n  var tail = GETTAIL(root);\n  var tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    if (start - BLOCK_OVERHEAD == changetype<usize>(tail)) {\n      start -= BLOCK_OVERHEAD;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  var size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  var leftSize = size - (BLOCK_OVERHEAD << 1);\n  var left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + size - BLOCK_OVERHEAD);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  // Here, both rounding performed in searchBlock ...\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\n  if (size < halfMaxSize) { // don't round last fl\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\n    size += (1 << (invRound - clz<usize>(size))) - 1;\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  var pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  var pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  var pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  var pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size >= BLOCK_MAXSIZE) throw new Error(\"allocation too large\");\n  return max<usize>((size + AL_MASK) & ~AL_MASK, BLOCK_MINSIZE); // align and ensure min size\n}\n\n/** Initilizes the root structure. */\nexport function initializeRoot(): void {\n  var rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n  var pagesBefore = memory.size();\n  var pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n  var root = changetype<Root>(rootOffset);\n  root.flMap = 0;\n  SETTAIL(root, changetype<Block>(0));\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n    SETSL(root, fl, 0);\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n      SETHEAD(root, fl, sl, null);\n    }\n  }\n  addMemory(root, (rootOffset + ROOT_SIZE + AL_MASK) & ~AL_MASK, memory.size() << 16);\n  ROOT = root;\n}\n\n// @ts-ignore: decorator\n@lazy\nvar collectLock: bool = false;\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize): Block {\n  if (DEBUG) assert(!collectLock); // must not allocate while collecting\n  var payloadSize = prepareSize(size);\n  var block = searchBlock(root, payloadSize);\n  if (!block) {\n    if (gc.auto) {\n      if (DEBUG) collectLock = true;\n      __collect();\n      if (DEBUG) collectLock = false;\n      block = searchBlock(root, payloadSize);\n      if (!block) {\n        growMemory(root, payloadSize);\n        block = <Block>searchBlock(root, payloadSize);\n        if (DEBUG) assert(block); // must be found now\n      }\n    } else {\n      growMemory(root, payloadSize);\n      block = <Block>searchBlock(root, payloadSize);\n      if (DEBUG) assert(block); // must be found now\n    }\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  block.gcInfo = 0; // RC=0\n  // block.rtId = 0; // set by the caller (__alloc)\n  block.rtSize = size;\n  removeBlock(root, <Block>block);\n  prepareBlock(root, <Block>block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(<Block>block);\n  return <Block>block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var blockInfo = block.mmInfo;\n  if (DEBUG) {\n    assert(\n      !(blockInfo & FREE) &&           // must be used\n      !(block.gcInfo & ~REFCOUNT_MASK) // not buffered or != BLACK\n    );\n  }\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= (blockInfo & ~TAGS_MASK)) {\n    prepareBlock(root, block, payloadSize);\n    block.rtSize = size;\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = (blockInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      // TODO: this can yield an intermediate block larger than BLOCK_MAXSIZE, which\n      // is immediately split though. does this trigger any assertions / issues?\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      block.rtSize = size;\n      prepareBlock(root, block, payloadSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  var newBlock = allocateBlock(root, size);\n  newBlock.rtId = block.rtId;\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, size);\n  block.mmInfo = blockInfo | FREE;\n  insertBlock(root, block);\n  if (isDefined(ASC_RTRACE)) onfree(block);\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  var blockInfo = block.mmInfo;\n  assert(!(blockInfo & FREE)); // must be used (user might call through to this)\n  block.mmInfo = blockInfo | FREE;\n  insertBlock(root, block);\n  if (isDefined(ASC_RTRACE)) onfree(block);\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize, id: u32): usize {\n  var root = ROOT;\n  if (!root) {\n    initializeRoot();\n    root = ROOT;\n  }\n  var block = allocateBlock(root, size);\n  block.rtId = id;\n  return changetype<usize>(block) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ref: usize, size: usize): usize {\n  if (DEBUG) assert(ROOT); // must be initialized\n  assert(ref != 0 && !(ref & AL_MASK)); // must exist and be aligned\n  return changetype<usize>(reallocateBlock(ROOT, changetype<Block>(ref - BLOCK_OVERHEAD), size)) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ref: usize): void {\n  if (DEBUG) assert(ROOT); // must be initialized\n  assert(ref != 0 && !(ref & AL_MASK)); // must exist and be aligned\n  freeBlock(ROOT, changetype<Block>(ref - BLOCK_OVERHEAD));\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\n/** Garbage collector interface. */\nexport namespace gc {\n\n  /** Can be set to `false` to disable automatic collection. Defaults to `true`. */\n  export var auto: bool = true;\n\n  /** Performs a full garbage collection cycle. */\n  export function collect(): void {\n    __collect();\n  }\n}\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { BLOCK, BLOCK_OVERHEAD } from \"./rt/common\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  var ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __instanceof(ref: usize, superId: u32): bool { // keyword\n  var id = changetype<BLOCK>(ref - BLOCK_OVERHEAD).rtId;\n  var ptr = __rtti_base;\n  if (id <= load<u32>(ptr)) {\n    do if (id == superId) return true;\n    while (id = changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).base);\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __allocArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  var array = __alloc(offsetof<i32[]>(), id);\n  var bufferSize = <usize>length << alignLog2;\n  var buffer = __alloc(bufferSize, idof<ArrayBuffer>());\n  store<usize>(array, __retain(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  store<usize>(array, buffer, offsetof<ArrayBufferView>(\"dataStart\"));\n  store<u32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(changetype<usize>(array), length, offsetof<i32[]>(\"length_\"));\n  if (data) memory.copy(buffer, data, bufferSize);\n  return array;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// @builtin @unsafe\n// export declare function __alloc(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ref: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ref: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __retain(ref: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __release(ref: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ref: usize, cookie: u32): void;\n","// Common error messages for use accross the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    var index: usize = 0;\n    var total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    let w: u32, x: u32;\n\n    // copy 1 byte each until src is aligned to 4 bytes\n    while (n && (src & 3)) {\n      store<u8>(dest++, load<u8>(src++));\n      n--;\n    }\n\n    // if dst is aligned to 4 bytes as well, copy 4 bytes each\n    if ((dest & 3) == 0) {\n      while (n >= 16) {\n        store<u32>(dest     , load<u32>(src     ));\n        store<u32>(dest +  4, load<u32>(src +  4));\n        store<u32>(dest +  8, load<u32>(src +  8));\n        store<u32>(dest + 12, load<u32>(src + 12));\n        src += 16; dest += 16; n -= 16;\n      }\n      if (n & 8) {\n        store<u32>(dest    , load<u32>(src    ));\n        store<u32>(dest + 4, load<u32>(src + 4));\n        dest += 8; src += 8;\n      }\n      if (n & 4) {\n        store<u32>(dest, load<u32>(src));\n        dest += 4; src += 4;\n      }\n      if (n & 2) { // drop to 2 bytes each\n        store<u16>(dest, load<u16>(src));\n        dest += 2; src += 2;\n      }\n      if (n & 1) { // drop to 1 byte\n        store<u8>(dest++, load<u8>(src++));\n      }\n      return;\n    }\n\n    // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n    // doing shifts if faster when copying enough bytes (here: 32 or more)\n    if (n >= 32) {\n      switch (dest & 3) {\n        // known to be != 0\n        case 1: {\n          w = load<u32>(src);\n          store<u8>(dest++, load<u8>(src++));\n          store<u8>(dest++, load<u8>(src++));\n          store<u8>(dest++, load<u8>(src++));\n          n -= 3;\n          while (n >= 17) {\n            x = load<u32>(src + 1);\n            store<u32>(dest, w >> 24 | x << 8);\n            w = load<u32>(src + 5);\n            store<u32>(dest + 4, x >> 24 | w << 8);\n            x = load<u32>(src + 9);\n            store<u32>(dest + 8, w >> 24 | x << 8);\n            w = load<u32>(src + 13);\n            store<u32>(dest + 12, x >> 24 | w << 8);\n            src += 16; dest += 16; n -= 16;\n          }\n          break;\n        }\n        case 2: {\n          w = load<u32>(src);\n          store<u8>(dest++, load<u8>(src++));\n          store<u8>(dest++, load<u8>(src++));\n          n -= 2;\n          while (n >= 18) {\n            x = load<u32>(src + 2);\n            store<u32>(dest, w >> 16 | x << 16);\n            w = load<u32>(src + 6);\n            store<u32>(dest + 4, x >> 16 | w << 16);\n            x = load<u32>(src + 10);\n            store<u32>(dest + 8, w >> 16 | x << 16);\n            w = load<u32>(src + 14);\n            store<u32>(dest + 12, x >> 16 | w << 16);\n            src += 16; dest += 16; n -= 16;\n          }\n          break;\n        }\n        case 3: {\n          w = load<u32>(src);\n          store<u8>(dest++, load<u8>(src++));\n          n -= 1;\n          while (n >= 19) {\n            x = load<u32>(src + 3);\n            store<u32>(dest, w >> 8 | x << 24);\n            w = load<u32>(src + 7);\n            store<u32>(dest + 4, x >> 8 | w << 24);\n            x = load<u32>(src + 11);\n            store<u32>(dest + 8, w >> 8 | x << 24);\n            w = load<u32>(src + 15);\n            store<u32>(dest + 12, x >> 8 | w << 24);\n            src += 16; dest += 16; n -= 16;\n          }\n          break;\n        }\n      }\n    }\n\n    // copy remaining bytes one by one\n    if (n & 16) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 8) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 4) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 2) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 1) {\n      store<u8>(dest++, load<u8>(src++));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src + n <= dest || dest + n <= src) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if ((src & 7) == (dest & 7)) {\n      while (dest & 7) {\n        if (!n) return;\n        --n;\n        store<u8>(dest++, load<u8>(src++));\n      }\n      while (n >= 8) {\n        store<u64>(dest, load<u64>(src));\n        n    -= 8;\n        dest += 8;\n        src  += 8;\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if ((src & 7) == (dest & 7)) {\n      while ((dest + n) & 7) {\n        if (!n) return;\n        store<u8>(dest + --n, load<u8>(src + n));\n      }\n      while (n >= 8) {\n        n -= 8;\n        store<u64>(dest + n, load<u64>(src + n));\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    store<u8>(dest, c);\n    store<u8>(dest + n - 1, c);\n    if (n <= 2) return;\n\n    store<u8>(dest + 1, c);\n    store<u8>(dest + 2, c);\n    store<u8>(dest + n - 2, c);\n    store<u8>(dest + n - 3, c);\n    if (n <= 6) return;\n    store<u8>(dest + 3, c);\n    store<u8>(dest + n - 4, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    store<u32>(dest, c32);\n    store<u32>(dest + n - 4, c32);\n    if (n <= 8) return;\n    store<u32>(dest + 4, c32);\n    store<u32>(dest + 8, c32);\n    store<u32>(dest + n - 12, c32);\n    store<u32>(dest + n - 8, c32);\n    if (n <= 24) return;\n    store<u32>(dest + 12, c32);\n    store<u32>(dest + 16, c32);\n    store<u32>(dest + 20, c32);\n    store<u32>(dest + 24, c32);\n    store<u32>(dest + n - 28, c32);\n    store<u32>(dest + n - 24, c32);\n    store<u32>(dest + n - 20, c32);\n    store<u32>(dest + n - 16, c32);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest + 8, c64);\n      store<u64>(dest + 16, c64);\n      store<u64>(dest + 24, c64);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\n  if (vl == vr) return 0;\n  if (ASC_SHRINK_LEVEL < 2) {\n    if ((vl & 7) == (vr & 7)) {\n      while (vl & 7) {\n        if (!n) return 0;\n        let a = <i32>load<u8>(vl);\n        let b = <i32>load<u8>(vr);\n        if (a != b) return a - b;\n        n--; vl++; vr++;\n      }\n      while (n >= 8) {\n        if (load<u64>(vl) != load<u64>(vr)) break;\n        vl += 8;\n        vr += 8;\n        n  -= 8;\n      }\n    }\n  }\n  while (n--) {\n    let a = <i32>load<u8>(vl);\n    let b = <i32>load<u8>(vr);\n    if (a != b) return a - b;\n    vl++; vr++;\n  }\n  return 0;\n}\n","export const enum CanvasInstruction {\n  Arc = 0,\n  ArcTo = 1,\n  BeginPath = 2,\n  BezierCurveTo = 3,\n  Clip = 4,\n  ClosePath = 5,\n  Commit = 6,\n  ClearRect = 7,\n  Direction = 8,\n  DrawFocusIfNeeded = 9,\n  DrawImage = 10,\n  Ellipse = 11,\n  Fill = 12,\n  FillGradient = 13,\n  FillPattern = 14,\n  FillRect = 15,\n  FillStyle = 16,\n  FillText = 17,\n  FillTextWidth = 18,\n  Filter = 19,\n  Font = 20,\n  GlobalAlpha = 21,\n  GlobalCompositeOperation = 22,\n  ImageSmoothingEnabled = 23,\n  ImageSmoothingQuality = 24,\n  Inspect = 25,\n  LineCap = 26,\n  LineDash = 27,\n  LineDashOffset = 28,\n  LineJoin = 29,\n  LineTo = 30,\n  LineWidth = 31,\n  MiterLimit = 32,\n  MoveTo = 33,\n  QuadraticCurveTo = 34,\n  Rect = 35,\n  Restore = 36,\n  Rotate = 37,\n  Save = 38,\n  Scale = 39,\n  SetTransform = 40,\n  ShadowBlur = 41,\n  ShadowColor = 42,\n  ShadowOffsetX = 43,\n  ShadowOffsetY = 44,\n  Stroke = 45,\n  StrokeGradient = 46,\n  StrokePattern = 47,\n  StrokeRect = 48,\n  StrokeStyle = 49,\n  StrokeText = 50,\n  StrokeTextWidth = 51,\n  TextAlign = 52,\n  TextBaseline = 53,\n  Translate = 54,\n  Transform = 55,\n}\n","/**\n * The CanvasRenderingContext2D.direction value of the Canvas 2D API specifies the current text\n * direction used to draw text onto the canvas.\n */\nexport enum CanvasDirection {\n  /**\n   * The text direction is left-to-right.\n   */\n  ltr = 0,\n  /**\n   * The text direction is right-to-left.\n   */\n  rtl = 1,\n  /**\n   * The text direction is inherited from the <canvas> element or the Document as appropriate. Default value.\n   */\n  inherit = 2,\n}\n","/**\n * A value indicating how to repeat the pattern's image.\n */\nexport enum CanvasPatternRepetition {\n  /**\n   * A canvas pattern repetition indicating a repeating pattern in both the x and y directions.\n   */\n  repeat = 0,\n  /**\n   * A canvas pattern repetition indicating a repeating pattern only the x direction.\n   */\n  repeat_x = 1,\n  /**\n   * A canvas pattern repetition indicating a repeating pattern only the y direction.\n   */\n  repeat_y = 2,\n  /**\n   * A canvas pattern repetition indicationg no repeating pattern.\n   */\n  no_repeat = 3,\n}\n","/**\n * The GlobalCompositeOperation enum for the globalCompositeOperation property sets the type\n * of compositing operation to apply when drawing new shapes.\n */\nexport enum GlobalCompositeOperation {\n  /**\n   * This is the default setting and draws new shapes on top of the existing canvas content\n   */\n  source_over = 0,\n  /**\n   * The new shape is drawn only where both the new shape and the destination canvas overlap.\n   * Everything else is made transparent.\n   */\n  source_in = 1,\n  /**\n   * The new shape is drawn where it doesn't overlap the existing canvas content.\n   */\n  source_out = 2,\n  /**\n   * The new shape is only drawn where it overlaps the existing canvas content.\n   */\n  source_atop = 3,\n  /**\n   * New shapes are drawn behind the existing canvas content.\n   */\n  destination_over = 4,\n  /**\n   * The existing canvas content is kept where both the new shape and existing canvas content\n   * overlap. Everything else is made transparent.\n   */\n  destination_in = 5,\n  /**\n   * The existing content is kept where it doesn't overlap the new shape.\n   */\n  destination_out = 6,\n  /**\n   * The existing canvas is only kept where it overlaps the new shape. The new shape is drawn\n   * behind the canvas content.\n   */\n  destination_atop = 7,\n  /**\n   * Where both shapes overlap the color is determined by adding color values.\n   */\n  lighter = 8,\n  /**\n   * Only the new shape is shown.\n   */\n  copy = 9,\n  /**\n   * Shapes are made transparent where both overlap and drawn normal everywhere else.\n   */\n  xor = 10,\n  /**\n   * The pixels are of the top layer are multiplied with the corresponding pixel of the bottom\n   * layer. A darker picture is the result.\n   */\n  multiply = 11,\n  /**\n   * The pixels are inverted, multiplied, and inverted again. A lighter picture is the result\n   * (opposite of multiply)\n   */\n  screen = 12,\n  /**\n   * A combination of multiply and screen. Dark parts on the base layer become darker, and light\n   * parts become lighter.\n   */\n  overlay = 13,\n  /**\n   * Retains the darkest pixels of both layers.\n   */\n  darken = 14,\n  /**\n   * Retains the lightest pixels of both layers.\n   */\n  lighten = 15,\n  /**\n   * Divides the bottom layer by the inverted top layer.\n   */\n  color_dodge = 16,\n  /**\n   * Divides the inverted bottom layer by the top layer, and then inverts the result.\n   */\n  color_burn = 17,\n  /**\n   * A combination of multiply and screen like overlay, but with top and bottom layer swapped.\n   */\n  hard_light = 18,\n  /**\n   * A softer version of hard-light. Pure black or white does not result in pure black or white.\n   */\n  soft_light = 19,\n  /**\n   * Subtracts the bottom layer from the top layer or the other way round to always get a positive\n   * value.\n   */\n  difference = 20,\n  /**\n   * Like difference, but with lower contrast.\n   */\n  exclusion = 21,\n  /**\n   * Preserves the luma and chroma of the bottom layer, while adopting the hue of the top layer.\n   */\n  hue = 22,\n  /**\n   * Preserves the luma and hue of the bottom layer, while adopting the chroma of the top layer.\n   */\n  saturation = 23,\n  /**\n   * Preserves the luma of the bottom layer, while adopting the hue and chroma of the top layer.\n   */\n  color = 24,\n  /**\n   * Preserves the hue and chroma of the bottom layer, while adopting the luma of the top layer.\n   */\n  luminosity = 25,\n}\n","export enum ImageSmoothingQuality {\n  low = 0,\n  medium = 1,\n  high = 2,\n}\n","export enum LineCap {\n  butt = 0,\n  round = 1,\n  square = 2,\n}\n","/**\n * The LineJoin enum responsible for setting the lineJoin property of the Canvas 2D API determines\n * the shape used to join two line segments where they meet.\n *\n * This property has no effect wherever two connected segments have the same direction, because no\n * joining area will be added in this case. Degenerate segments with a length of zero (i.e., with\n * all endpoints and control points at the exact same position) are also ignored.\n */\nexport enum LineJoin {\n  /**\n   * Rounds off the corners of a shape by filling an additional sector of disc centered at the\n   * common endpoint of connected segments. The radius for these rounded corners is equal to the\n   * line width.\n   */\n  bevel = 0,\n  /**\n   * Fills an additional triangular area between the common endpoint of connected segments, and the\n   * separate outside rectangular corners of each segment.\n   */\n  round = 1,\n  /**\n   * Connected segments are joined by extending their outside edges to connect at a single point,\n   * with the effect of filling an additional lozenge-shaped area. This setting is affected by the\n   * miterLimit property. Default value.\n   */\n  miter = 2,\n}\n","/**\n * The TextAlign enum specifies the current text alignment used when drawing text.\n *\n * The alignment is relative to the x value of the fillText() method. For example, if textAlign is\n * \"center\", then the text's left edge will be at x - (textWidth / 2).\n */\nexport enum TextAlign {\n  /**\n   * The text is left-aligned.\n   **/\n  left = 0,\n  /**\n   * The text is right-aligned.\n   **/\n  right = 1,\n  /**\n   * The text is centered.\n   **/\n  center = 2,\n  /**\n   * The text is aligned at the normal start of the line (left-aligned for left-to-right locales, right-aligned for right-to-left locales).\n   **/\n  start = 3,\n  /**\n   * The text is aligned at the normal end of the line (right-aligned for left-to-right locales, left-aligned for right-to-left locales).\n   **/\n  end = 4,\n}\n","/**\n * The TextBasline enum specifies the current text baseline used when drawing text.\n */\nexport enum TextBaseline {\n  /**\n   * The text baseline is the top of the em square.\n   **/\n  top = 0,\n  /**\n   * The text baseline is the hanging baseline. (Used by Tibetan and other Indic scripts.)\n   **/\n  hanging = 1,\n  /**\n   * The text baseline is the middle of the em square.\n   **/\n  middle = 2,\n  /**\n   * The text baseline is the normal alphabetic baseline. Default value.\n   **/\n  alphabetic = 3,\n  /**\n   * The text baseline is the ideographic baseline; this is the bottom of the body of the characters, if the main body of characters protrudes beneath the alphabetic baseline. (Used by Chinese, Japanese, and Korean scripts.)\n   **/\n  ideographic = 4,\n  /**\n   * The text baseline is the bottom of the bounding box. This differs from the ideographic baseline in that the ideographic baseline doesn't consider descenders.\n   **/\n  bottom = 5,\n}\n","export enum FillRule {\n  nonzero = 0,\n  evenodd = 1,\n}\n","//#endregion EXTERNALS\nexport const enum FillStrokeStyleType {\n  String = 0,\n  CanvasPattern = 1,\n  CanvasGradient = 2\n}\n","import { CanvasInstruction } from \"../../src/shared/CanvasInstruction\";\nimport { Buffer } from \"../internal/Buffer\";\nimport { DOMMatrix } from \"./DOMMatrix\";\nimport { CanvasDirection } from \"../../src/shared/CanvasDirection\";\nimport { CanvasPattern } from \"./CanvasPattern\";\nimport { CanvasGradient } from \"./CanvasGradient\";\nimport { Image, getImageID } from \"./Image\";\nimport { CanvasPatternRepetition } from \"../../src/shared/CanvasPatternRepetition\";\nimport { GlobalCompositeOperation } from \"../../src/shared/GlobalCompositeOperation\";\nimport { ImageSmoothingQuality } from \"../../src/shared/ImageSmoothingQuality\";\nimport { LineCap } from \"../../src/shared/LineCap\";\nimport { LineJoin } from \"../../src/shared/LineJoin\";\nimport { TextAlign } from \"../../src/shared/TextAlign\";\nimport { TextBaseline } from \"../../src/shared/TextBaseline\";\nimport { arraysEqual } from \"../internal/util\";\nimport { Path2DElement } from \"../internal/Path2DElement\";\nimport { FillRule } from \"../../src/shared/FillRule\";\nimport { STORE, LOAD } from \"../internal/util\";\nimport { StackPointer } from \"../internal/StackPointer\";\nimport { CanvasStack } from \"./CanvasStack\";\nimport { FillStrokeStyleType } from \"../internal/FillStrokeStyleType\";\n\n// @ts-ignore: linked functions can have decorators\n@external(\"__canvas_sys\", \"render\")\ndeclare function render(ctxid: i32, data: usize): void;\n\n// @ts-ignore: linked functions can have decorators\n@external(\"__canvas_sys\", \"createLinearGradient\")\ndeclare function createLinearGradient(id: i32, x0: f64, y0: f64, x1: f64, y1: f64): i32;\n\n// @ts-ignore: linked functions can have decorators\n@external(\"__canvas_sys\", \"createRadialGradient\")\ndeclare function createRadialGradient(id: i32, x0: f64, y0: f64, r0: f64, x1: f64, y1: f64, r1: f64): i32;\n\n// @ts-ignore: linked functions can have decorators\n@external(\"__canvas_sys\", \"createPattern\")\ndeclare function createPattern(ctxid: i32, imageid: i32, repetition: CanvasPatternRepetition): i32;\n\n// @ts-ignore: linked functions can have decorators\n@external(\"__canvas_sys\", \"measureText\")\ndeclare function measureText(id: i32, text: string): f64;\n\n// @ts-ignore: linked functions can have decorators\n@external(\"__canvas_sys\", \"isPointInPath\")\ndeclare function isPointInPath(id: i32, x: f64, y: f64, fillRule: FillRule): bool;\n\n// @ts-ignore: linked functions can have decorators\n@external(\"__canvas_sys\", \"isPointInStroke\")\ndeclare function isPointInStroke(id: i32, x: f64, y: f64): bool;\nvar defaultBlack: string = \"#000\";\nvar defaultNone: string = \"none\";\nvar defaultFont: string = \"10px sans-serif\";\nvar defaultShadowColor: string = \"rgba(0, 0, 0, 0)\";\nvar defaultLineDash: Float64Array = new Float64Array(0);\n\n//#region ARRAYBUFFERINITIALIZER\n/**\n * Utility function for setting the given ArrayBuffer to the identity 2d transform matrix inline.\n *\n * @param ArrayBuffer buff\n */\n// @ts-ignore: Decorators are valid here\nfunction setArrayBufferIdentity(buff: usize): usize {\n  STORE<f64>(buff, 0, 1.0);\n  STORE<f64>(buff, 1, 0.0);\n  STORE<f64>(buff, 2, 0.0);\n  STORE<f64>(buff, 3, 1.0);\n  STORE<f64>(buff, 4, 0.0);\n  STORE<f64>(buff, 5, 0.0);\n  return buff;\n}\n\nfunction initializeStackPointer(pointer: StackPointer<CanvasStack>): StackPointer<CanvasStack> {\n  let stack = pointer.reference();\n  stack.a = 1;\n  stack.d = 1;\n  stack.direction = CanvasDirection.inherit;\n  stack.fillStyleType = FillStrokeStyleType.String;\n  stack.fillStyleString = defaultBlack;\n  __retain(changetype<usize>(defaultBlack));\n  stack.filter = defaultNone;\n  __retain(changetype<usize>(defaultNone));\n  stack.font = defaultFont;\n  __retain(changetype<usize>(defaultFont));\n  stack.globalAlpha = 1.0;\n  stack.globalCompositeOperation = GlobalCompositeOperation.source_over;\n  stack.imageSmoothingEnabled = true;\n  stack.imageSmoothingQuality = ImageSmoothingQuality.low;\n  stack.lineCap = LineCap.butt;\n  stack.lineDash = defaultLineDash;\n  stack.lineJoin = LineJoin.miter;\n  stack.lineWidth = 1.0;\n  stack.miterLimit = 10.0;\n  stack.shadowBlur = 0.0;\n  stack.shadowColor = defaultShadowColor;\n  stack.strokeStyleString = defaultBlack;\n  __retain(changetype<usize>(defaultBlack));\n  __retain(changetype<usize>(defaultShadowColor));\n  return pointer;\n}\n\n\n/** The path element initializer. */\nfunction createPathElements(): StackPointer<Path2DElement> {\n  let pointer = StackPointer.create<Path2DElement>(0x1000);\n  let reference = pointer.reference();\n  reference.instruction = CanvasInstruction.BeginPath;\n  reference.count = 0;\n  reference.updateTransform = true;\n  reference.transformA = 1.0;\n  reference.transformD = 1.0;\n  return pointer;\n}\n\n/**\n * An AssemblyScript virtual representation of an actual CanvasRenderingContext2D Object. The\n * CanvasRenderingContext2D interface, part of the Canvas API, provides the 2D rendering context\n * for the drawing surface of a <canvas> element. It is used for drawing shapes, text, images, and\n * other objects.\n */\n@sealed\nexport class CanvasRenderingContext2D extends Buffer<CanvasInstruction> {\n  /**\n   * The component's external object id. It initializes to -1, which will never be an actual object\n   * id externally. If it actually returns -1, it will cause the host to error saying it cannot\n   * find the specified canvas context.\n   */\n  private id: i32 = -1;\n\n  /**\n   * The virutal stack index offset that keeps track of the number of `save()` and `restore()`\n   * stack states.\n   */\n  private _stackOffset: u8 = <u8>0;\n\n  //#region CREATELINEARGRADIENT\n  /**\n   * The CanvasRenderingContext2D.createLinearGradient() method of the Canvas 2D API creates a\n   * gradient along the line connecting two given coordinates.\n   *\n   * @param {f64} x0 - A float number representing the first x coordinate point of the gradient.\n   * @param {f64} y0 - A float number representing the first y coordinate point of the gradient.\n   * @param {f64} x1 - A float number representing the second x coordinate point of the gradient.\n   * @param {f64} y1 - A float number representing the second y coordinate point of the gradient.\n   */\n  public createLinearGradient(x0: f64, y0: f64, x1: f64, y1: f64): CanvasGradient {\n    var id: i32 = createLinearGradient(this.id, x0, y0, x1, y1);\n    var result: CanvasGradient = new CanvasGradient();\n    store<i32>(changetype<usize>(result), id, offsetof<CanvasGradient>(\"id\"));\n    return result;\n  }\n  //#endregion CREATELINEARGRADIENT\n\n  //#region CREATERADIALGRADIENT\n  /**\n   * The CanvasRenderingContext2D.createRadialGradient() method of the Canvas 2D API creates a\n   * radial gradient using the size and coordinates of two circles.\n   *\n   * @param {f64} x0 - The x-axis coordinate of the start circle.\n   * @param {f64} y0 - The y-axis coordinate of the start circle.\n   * @param {f64} r0 - The radius of the start circle. Must be non-negative and finite.\n   * @param {f64} x1 - The x-axis coordinate of the end circle.\n   * @param {f64} y1 - The y-axis coordinate of the end circle.\n   * @param {f64} r1 - The radius of the end circle. Must be non-negative and finite.\n   */\n  public createRadialGradient(x0: f64, y0: f64, r0: f64, x1: f64, y1: f64, r1: f64): CanvasGradient {\n    var id: i32 = createRadialGradient(this.id, x0, y0, r0, x1, y1, r1);\n    var result: CanvasGradient = new CanvasGradient();\n    store<i32>(changetype<usize>(result), id, offsetof<CanvasGradient>(\"id\"));\n    return result;\n  }\n  //#endregion CREATERADIALGRADIENT\n\n  private _stack: StackPointer<CanvasStack> = initializeStackPointer(StackPointer.create<CanvasStack>(0xFF));\n\n  //#region TRANSFORM\n\n  /**\n   * An ArrayBuffer that contains a single transform value that represents the last transform\n   * written by a `setTransform()` operation\n   */\n  private _currentTransform: ArrayBuffer = changetype<ArrayBuffer>(setArrayBufferIdentity(__alloc(sizeof<f64>() * 6, idof<ArrayBuffer>())));\n\n  /**\n   * An operation that generates a DOMMatrix reflecting the current transform on the `_transformStack\n   */\n  @inline\n  private _getTransform(): DOMMatrix {\n    var result: DOMMatrix = new DOMMatrix();\n    var stack = this._stack.reference();\n    result.m11 = stack.a;\n    result.m12 = stack.b;\n    result.m21 = stack.c;\n    result.m22 = stack.d;\n    result.m41 = stack.e;\n    result.m42 = stack.f;\n    return result;\n  }\n\n  /**\n   * An function that sets the current transform on the `_transformStack` to the specified\n   * DOMMatrix values.\n   *\n   * @param {f64} a - The a property of the transform matrix.\n   * @param {f64} b - The b property of the transform matrix.\n   * @param {f64} c - The c property of the transform matrix.\n   * @param {f64} d - The d property of the transform matrix.\n   * @param {f64} e - The e property of the transform matrix.\n   * @param {f64} f - The f property of the transform matrix.\n   */\n  @inline\n  private _setTransform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\n    var stack = this._stack.reference();\n    stack.a = a;\n    stack.b = b;\n    stack.c = c;\n    stack.d = d;\n    stack.e = e;\n    stack.f = f;\n  }\n\n  /**\n   * The CanvasRenderingContext2D.currentTransform property of the Canvas 2D API returns or sets a\n   * DOMMatrix (current specification) object for the current transformation matrix\n  */\n  public get currentTransform(): DOMMatrix {\n    return this._getTransform();\n  }\n\n  public set currentTransform(value: DOMMatrix) {\n    this._setTransform(value.m11, value.m12, value.m21, value.m22, value.m41, value.m42);\n  }\n\n  /**\n   * The CanvasRenderingContext2D.getTransform() method of the Canvas 2D API gets the current\n   * transformation matrix, and returns a DOMMatrix\n   */\n  public getTransform(): DOMMatrix {\n    return this._getTransform();\n  }\n\n  /**\n   * An internal function that writes the current transform value on the _transformStack to the\n   * buffer if it currently does not match the last written transform.\n   */\n  private _updateTransform(): void {\n    var stack = this._stack.reference();\n    var a = stack.a;\n    var b = stack.b;\n    var c = stack.c;\n    var d = stack.d;\n    var e = stack.e;\n    var f = stack.f;\n\n    var current = changetype<usize>(this._currentTransform);\n    if ( a != LOAD<f64>(current, 0)\n      || b != LOAD<f64>(current, 1)\n      || c != LOAD<f64>(current, 2)\n      || d != LOAD<f64>(current, 3)\n      || e != LOAD<f64>(current, 4)\n      || f != LOAD<f64>(current, 5)) {\n      super._writeSix(CanvasInstruction.SetTransform, a, b, c, d, e, f);\n      STORE<f64>(current, 0, a);\n      STORE<f64>(current, 1, b);\n      STORE<f64>(current, 2, c);\n      STORE<f64>(current, 3, d);\n      STORE<f64>(current, 4, e);\n      STORE<f64>(current, 5, f);\n    }\n  }\n  //#endregion TRANSFORM\n\n  //#region DIRECTION\n\n  /**\n   * A private member that contains a single CanvasDirection value that represents the last\n   * CanvasDirection value written by a drawing operation\n   */\n  private _currentDirection: CanvasDirection = CanvasDirection.inherit;\n\n  /**\n   * The CanvasRenderingContext2D.direction property of the Canvas 2D API specifies the current text\n   * direction used to draw text\n   */\n  public get direction(): CanvasDirection {\n    return this._stack.reference().direction;\n  }\n\n  public set direction(value: CanvasDirection) {\n    this._stack.reference().direction = value;\n  }\n\n  /**\n   * An internal function that writes the current CanvasDirection value on the _directionStack to\n   * the buffer if it currently does not match the last written CanvasDirection.\n   */\n  @inline\n  private _updateDirection(): void {\n    var value: CanvasDirection = this._stack.reference().direction;\n    if (value != this._currentDirection) {\n      this._currentDirection = value;\n      super._writeOne(CanvasInstruction.Direction, <f64>value);\n    }\n  }\n  //#endregion DIRECTION\n\n  //#region FILLSTYLE\n  /**\n   * A private member that contains a single StrokeFillStyleType value that represents the last\n   * fillStyle value written by a drawing operation\n   */\n  private _currentFillStyleType: FillStrokeStyleType = FillStrokeStyleType.String;\n\n  /**\n   * A private member that contains a single pointer or id value that represents the last\n   * fillStyle value written by a drawing operation\n   */\n  private _currentFillStyleValue: usize = changetype<usize>(defaultBlack);\n\n  /**\n   * The CanvasRenderingContext2D.fillStyle property of the Canvas 2D API specifies the current text\n   * representing a CSS Color\n   */\n  public get fillStyle(): string | null {\n    var stack = this._stack.reference();\n    return stack.fillStyleType === FillStrokeStyleType.String\n      ? stack.fillStyleString\n      : null;\n  }\n\n  public set fillStyle(value: string | null) {\n    if (value == null) value = defaultBlack;\n    let stack = this._stack.reference();\n    let currentType = stack.fillStyleType;\n    stack.fillStyleType = FillStrokeStyleType.String;\n    __retain(changetype<usize>(value));\n    if (currentType == FillStrokeStyleType.CanvasGradient) {\n      __release(changetype<usize>(stack.fillStyleGradient));\n      stack.fillStyleGradient = null;\n    } else if (currentType == FillStrokeStyleType.CanvasPattern) {\n      __release(changetype<usize>(stack.fillStylePattern));\n      stack.fillStylePattern = null;\n    } else {\n      __release(changetype<usize>(stack.fillStyleString));\n    }\n    stack.fillStyleString = value!;\n    stack.fillStyleValue = changetype<usize>(value);\n  }\n\n  /**\n   * An internal function that writes the current fillStyle value on the _fillStyleStack to the\n   * buffer if it currently does not match the last written fillStyle.\n   */\n  @inline\n  private _updateFillStyle(): void {\n    var stack = this._stack.reference();\n    var styleType = stack.fillStyleType;\n\n    var pointer: usize = 0;\n    var value: f64 = 0;\n    if (styleType === FillStrokeStyleType.String) {\n      pointer = changetype<usize>(stack.fillStyleString);\n      value = pointer;\n    } else if (styleType === FillStrokeStyleType.CanvasGradient) {\n      pointer = changetype<usize>(stack.fillStyleGradient);\n      value = <f64>load<i32>(pointer, offsetof<CanvasGradient>(\"id\"));\n    } else if (styleType === FillStrokeStyleType.CanvasPattern) {\n      pointer = changetype<usize>(stack.fillStylePattern);\n      value = <f64>load<i32>(pointer, offsetof<CanvasPattern>(\"id\"));\n    }\n\n    if (styleType != this._currentFillStyleType || value != this._currentFillStyleValue) {\n      var inst: CanvasInstruction;\n      if (styleType == FillStrokeStyleType.String) inst = CanvasInstruction.FillStyle;\n      else if (styleType == FillStrokeStyleType.CanvasGradient) inst = CanvasInstruction.FillGradient;\n      else inst = CanvasInstruction.FillPattern;\n      super._retain(pointer);\n      super._writeOne(inst, <f64>value);\n    }\n  }\n  //#endregion FILLSTYLE\n\n  //#region FILLPATTERN\n  /**\n   * The CanvasRenderingContext2D.fillPattern property of the Canvas 2D API specifies the current\n   * fillStyle pattern\n   */\n  public get fillPattern(): CanvasPattern | null {\n    var stack = this._stack.reference();\n    return stack.fillStyleType === FillStrokeStyleType.CanvasPattern\n      ? stack.fillStylePattern\n      : null;\n  }\n\n  public set fillPattern(value: CanvasPattern | null) {\n    if (value == null) {\n      this.fillStyle = defaultBlack;\n      return;\n    }\n    __retain(changetype<usize>(value));\n    var stack = this._stack.reference();\n    __release(changetype<usize>(stack.fillStylePattern));\n    stack.fillStyleType = FillStrokeStyleType.CanvasPattern;\n    stack.fillStylePattern = value;\n    stack.fillStyleValue = <usize>load<i32>(changetype<usize>(value), offsetof<CanvasPattern>(\"id\"));\n  }\n  //#endregion FILLPATTERN\n\n  //#region FILLGRADIENT\n  /**\n   * The CanvasRenderingContext2D.fillGradient property of the Canvas 2D API specifies the current\n   * fillStyle gradient\n   */\n  public get fillGradient(): CanvasGradient | null {\n    var stack = this._stack.reference();\n    return stack.fillStyleType == FillStrokeStyleType.CanvasGradient\n      ? stack.fillStyleGradient\n      : null;\n  }\n\n  public set fillGradient(value: CanvasGradient | null) {\n    if (value == null) {\n      this.fillStyle = defaultBlack;\n      return;\n    }\n    __retain(changetype<usize>(value));\n    var stack = this._stack.reference();\n    stack.fillStyleType = FillStrokeStyleType.CanvasGradient;\n    __release(changetype<usize>(stack.fillStyleGradient));\n    stack.fillStyleGradient = value;\n    stack.fillStyleValue = <usize>load<i32>(changetype<usize>(value), offsetof<CanvasGradient>(\"id\"));\n  }\n  //#endregion FILLGRADIENT\n\n  //#region CREATEPATTERN\n  /**\n   * The CanvasRenderingContext2D.createPattern() method of the Canvas 2D API creates a pattern\n   * using the specified image and repetition.\n   *\n   * @param {Image} img - A CanvasImageSource to be used as the pattern's Image.\n   * @param {CanvasPatternRepetition} repetition - An enum value indicating how to repeat the pattern's image.\n   */\n  public createPattern(img: Image, repetition: CanvasPatternRepetition): CanvasPattern {\n    var result = new CanvasPattern();\n    var id: i32 = load<i32>(changetype<usize>(img), offsetof<Image>(\"_id\"));\n    store<i32>(changetype<usize>(result), createPattern(this.id, id, repetition), offsetof<CanvasPattern>(\"id\"));\n    return result;\n  }\n  //#endregion CREATEPATTERN\n\n  //#region FILTER\n  /**\n   * A private member that contains a single string value that represents the last\n   * filter value written by a drawing operation.\n   */\n  private _currentFilter: string = defaultNone;\n\n  /**\n   * The CanvasRenderingContext2D.filter property of the Canvas 2D API provides filter effects such\n   * as blurring and grayscaling. It is similar to the CSS filter property and accepts the same\n   * values.\n   */\n  public get filter(): string {\n    return this._stack.reference().filter;\n  }\n\n  public set filter(value: string) {\n    let stack = this._stack.reference();\n    __retain(changetype<usize>(value));\n    __release(changetype<usize>(stack.filter));\n    stack.filter = value;\n  }\n\n  /**\n   * An internal function that writes the current filter value on the _filterStack if it currently\n   * does not match the last written filter string value to the buffer using write_one.\n   */\n  @inline\n  private _updateFilter(): void {\n    var value: string = this._stack.reference().filter;\n    if (value != this._currentFilter) {\n      this._currentFilter = value;\n      super._retain(changetype<usize>(value));\n      super._writeOne(CanvasInstruction.Filter, changetype<usize>(value));\n    }\n  }\n  //#endregion FILTER\n\n  //#region FONT\n  /**\n   * A private member that contains a single string value that represents the last\n   * font value written by a drawing operation.\n   */\n  private _currentFont: string = defaultFont;\n\n  /**\n   * The CanvasRenderingContext2D.font property of the Canvas 2D API specifies the current text\n   * style to use when drawing text. This string uses the same syntax as the CSS font specifier.\n   */\n  public get font(): string {\n    return this._stack.reference().font;\n  }\n\n  public set font(value: string) {\n    let stack = this._stack.reference();\n    __retain(changetype<usize>(value));\n    __release(changetype<usize>(stack.font));\n    stack.font = value;\n  }\n\n  /**\n   * An internal function that writes the current font value on the _fontStack to the buffer if it\n   * currently does not match the last written font string value.\n   */\n  @inline\n  private _updateFont(): void {\n    var value: string = this._stack.reference().font;\n    if (value != this._currentFont) {\n      this._currentFont = value;\n      super._retain(changetype<usize>(value));\n      super._writeOne(CanvasInstruction.Font, changetype<usize>(value));\n    }\n  }\n  //#endregion FONT\n\n  //#region GLOBALALPHA\n  /**\n   * A private member that contains a single float value that represents the last globalAlpha value\n   * written by a drawing operation.\n   */\n  private _currentGlobalAlpha: f64 = 1.0;\n\n  /**\n   * The CanvasRenderingContext2D.globalAlpha property of the Canvas 2D API specifies the alpha\n   * (transparency) value that is applied to shapes and images before they are drawn onto the\n   * canvas.\n   */\n  public get globalAlpha(): f64 {\n    return this._stack.reference().globalAlpha;\n  }\n\n  public set globalAlpha(value: f64) {\n    if (!isFinite(value) || value < 0.0 || value > 1.0) return;\n    this._stack.reference().globalAlpha = value;\n  }\n\n  /**\n   * An internal function that writes the current globalAlpha value on the _globalAlphaStack to the\n   * buffer if it currently does not match the last written globalAlpha value.\n   */\n  @inline\n  private _updateGlobalAlpha(): void {\n    var value: f64 = this._stack.reference().globalAlpha;\n    if (value != this._currentGlobalAlpha) {\n      this._currentGlobalAlpha = value;\n      super._writeOne(CanvasInstruction.GlobalAlpha, value);\n    }\n  }\n  //#endregion GLOBALALPHA\n\n  //#region GLOBALCOMPOSITEOPERATION\n  /**\n   * A private member that contains a single GlobalCompositeOperation value that represents the last\n   * globalCompositeOperation value written by a drawing operation.\n   */\n  private _currentGlobalCompositeOperation: GlobalCompositeOperation = GlobalCompositeOperation.source_over;\n\n  /**\n   * The CanvasRenderingContext2D.globalCompositeOperation property of the Canvas 2D API sets the\n   * type of compositing operation to apply when drawing new shapes.\n   */\n  public get globalCompositeOperation(): GlobalCompositeOperation {\n    return this._stack.reference().globalCompositeOperation;\n  }\n\n  public set globalCompositeOperation(value: GlobalCompositeOperation) {\n    this._stack.reference().globalCompositeOperation = value;\n  }\n\n  /**\n   * An internal function that writes the current globalCompositeOperation value on the\n   * _globalCompositeOperationStack to the buffer if it currently does not match the last written\n   * globalCompositeOperation value.\n   */\n  @inline\n  private _updateGlobalCompositeOperation(): void {\n    var value: GlobalCompositeOperation = this._stack.reference().globalCompositeOperation;\n    if (value != this._currentGlobalCompositeOperation) {\n      this._currentGlobalCompositeOperation = value;\n      super._writeOne(CanvasInstruction.GlobalCompositeOperation, <f64>value);\n    }\n  }\n  //#endregion GLOBALCOMPOSITEOPERATION\n\n  //#region IMAGESMOOTHINGENABLED\n\n  /**\n   * A private member that contains a single bool value that represents the last\n   * imageSmoothingEnabled value written by a drawing operation.\n   */\n  private _currentImageSmoothingEnabled: bool = true;\n\n  /**\n   * The imageSmoothingEnabled property of the CanvasRenderingContext2D interface, part of the\n   * Canvas API, determines whether scaled images are smoothed (true, default) or not (false). On\n   * getting the imageSmoothingEnabled property, the last value it was set to is returned.\n   */\n  public get imageSmoothingEnabled(): bool {\n    return this._stack.reference().imageSmoothingEnabled;\n  }\n\n  public set imageSmoothingEnabled(value: bool) {\n    this._stack.reference().imageSmoothingEnabled = value;\n  }\n\n  /**\n   * An internal function that writes the current imageSmoothingEnabled value on the\n   * _imageSmoothingEnabledStack to the buffer if it currently does not match the last written\n   * imageSmoothingEnabled value.\n   */\n  @inline\n  private _updateImageSmoothingEnabled(): void {\n    var value: bool = this._stack.reference().imageSmoothingEnabled;\n    if (value != this._currentImageSmoothingEnabled) {\n      this._currentImageSmoothingEnabled = value;\n      super._writeOne(CanvasInstruction.ImageSmoothingEnabled, value ? 1.0 : 0.0);\n    }\n  }\n  //#endregion IMAGESMOOTHINGENABLED\n\n  //#region IMAGESMOOTHINGQUALITY\n  /**\n   * A private member that contains a single ImageSmoothingQuality value that represents the last\n   * imageSmoothingQuality value written by a drawing operation.\n   */\n  private _currentImageSmoothingQuality: ImageSmoothingQuality = ImageSmoothingQuality.low;\n\n  /**\n   * The imageSmoothingQuality property of the CanvasRenderingContext2D interface, part of the\n   * Canvas API, lets you set the quality of image smoothing.\n   */\n  public get imageSmoothingQuality(): ImageSmoothingQuality {\n    return this._stack.reference().imageSmoothingQuality;\n  }\n\n  public set imageSmoothingQuality(value: ImageSmoothingQuality) {\n    this._stack.reference().imageSmoothingQuality = value;\n  }\n\n  /**\n   * An internal function that writes the current imageSmoothingQuality value on the\n   * _imageSmoothingQualityStack to the buffer if it currently does not match the last written\n   * imageSmoothingQuality value, and imageSmoothingEnabled is true.\n   */\n  @inline\n  private _updateImageSmoothingQuality(): void {\n    let stack = this._stack.reference();\n    let enabled = stack.imageSmoothingEnabled;\n    if (enabled) {\n      let value = stack.imageSmoothingQuality;\n      if (value != this._currentImageSmoothingQuality) {\n        this._currentImageSmoothingQuality = value;\n        super._writeOne(CanvasInstruction.ImageSmoothingQuality, <f64>value);\n      }\n    }\n  }\n  //#endregion IMAGESMOOTHINGQUALITY\n\n  //#region LINECAP\n  /**\n   * A private member that contains a single LineCap value that represents the last\n   * lineCap value written by a drawing operation.\n   */\n  private _currentLineCap: LineCap = LineCap.butt;\n\n  /**\n   * The CanvasRenderingContext2D.lineCap property of the Canvas 2D API determines the shape used\n   * to draw the end points of lines.\n   */\n  public get lineCap(): LineCap {\n    return this._stack.reference().lineCap;\n  }\n\n  public set lineCap(value: LineCap) {\n    this._stack.reference().lineCap = value;\n  }\n\n  /**\n   * An internal function that writes the current lineCap value on the _lineCapStack to the buffer\n   * if it currently does not match the last written lineCap value.\n   */\n  @inline\n  private _updateLineCap(): void {\n    var value: LineCap = this._stack.reference().lineCap;\n    if (value != this._currentLineCap) {\n      this._currentLineCap = value;\n      super._writeOne(CanvasInstruction.LineCap, <f64>value);\n    }\n  }\n  //#endregion LINECAP\n\n  //#region LINEDASH\n  /**\n   * A private member that contains a single LineCap value that represents the last\n   * lineCap value written by a drawing operation.\n   */\n  private _currentLineDash: Float64Array = defaultLineDash;\n\n  /**\n   * The getLineDash() method of the Canvas 2D API's CanvasRenderingContext2D interface gets the\n   * current line dash pattern.\n   */\n  public getLineDash(): Float64Array {\n    return this._getLineDash();\n  }\n\n  /**\n   * The setLineDash() method of the Canvas 2D API's CanvasRenderingContext2D interface sets the\n   * line dash pattern used when stroking lines. It uses a Float64Array of values that specify\n   * alternating lengths of lines and gaps which describe the pattern.\n   *\n   * @param {Float64Array} value - An Array of numbers that specify distances to alternately draw a\n   * line and a gap (in coordinate space units). If the number of elements in the array is odd, the\n   * elements of the array get copied and concatenated. For example, Float64Array [5, 15, 25] will\n   * become Float64Array [5, 15, 25, 5, 15, 25]. If the array is empty, the line dash list is\n   * cleared and line strokes return to being solid.\n   */\n  public setLineDash(value: Float64Array): void {\n    let stack = this._stack.reference();\n    __release(changetype<usize>(stack.lineDash));\n    __retain(changetype<usize>(value));\n    stack.lineDash = value;\n  }\n\n  /**\n   * An internal getLineDash function that loops backwards from the current stackOffset until it\n   * doesn't find a null pointer, then returns the reference.\n   */\n  @inline\n  private _getLineDash(): Float64Array {\n    return this._stack.reference().lineDash;\n  }\n\n  /**\n   * An internal function that writes the current lineDash value on the _lineDashStack to the buffer\n   * if it currently does not match the last written lineCap value.\n   */\n  @inline\n  private _updateLineDash(): void {\n    var lineDash: Float64Array = this._getLineDash();\n    var current: Float64Array = this._currentLineDash;\n\n    if (!arraysEqual(current, lineDash)) {\n      this._currentLineDash = lineDash;\n      let pointer = changetype<usize>(lineDash);\n      super._retain(pointer);\n      super._writeOne(CanvasInstruction.LineDash, <f64>pointer);\n    }\n  }\n  //#endregion LINEDASH\n\n  //#region LINEDASHOFFSET\n  /**\n   * A private member that contains a single float value that represents the last lineDashOffset value\n   * written by a drawing operation.\n   */\n  private _currentLineDashOffset: f64 = 0.0;\n\n  /**\n   * The CanvasRenderingContext2D.lineDashOffset property of the Canvas 2D API sets the line dash\n   * offset, or \"phase.\"\n   */\n  public get lineDashOffset(): f64 {\n    return this._stack.reference().lineDashOffset;\n  }\n\n  public set lineDashOffset(value: f64) {\n    if (!isFinite(value)) return;\n    this._stack.reference().lineDashOffset = value;\n  }\n\n  /**\n   * An internal function that writes the current lineDashOffset value on the _lineDashOffsetStack\n   * to the buffer if it currently does not match the last written lineDashOffset value.\n   */\n  @inline\n  private _updateLineDashOffset(): void {\n    var value: f64 = this._stack.reference().lineDashOffset;\n    if (value != this._currentLineDashOffset) {\n      this._currentLineDashOffset = value;\n      super._writeOne(CanvasInstruction.LineDashOffset, value);\n    }\n  }\n  //#endregion LINEDASHOFFSET\n\n  //#region LINEJOIN\n  /**\n   * A private member that contains a single LineJoin value that represents the last\n   * lineJoin value written by a drawing operation.\n   */\n  private _currentLineJoin: LineJoin = LineJoin.miter;\n\n  /**\n   * The CanvasRenderingContext2D.lineJoin property of the Canvas 2D API determines the shape used\n   * to join two line segments where they meet.\n   *\n   * This property has no effect wherever two connected segments have the same direction, because\n   * no joining area will be added in this case. Degenerate segments with a length of zero (i.e.,\n   * with all endpoints and control points at the exact same position) are also ignored.\n   */\n  public get lineJoin(): LineJoin {\n    return this._stack.reference().lineJoin;\n  }\n\n  public set lineJoin(value: LineJoin) {\n    this._stack.reference().lineJoin = value;\n  }\n\n  /**\n   * An internal function that writes the current lineJoin value on the  _lineJoinStack if it\n   * currently does not match the last written lineJoin value.\n   */\n  @inline\n  private _updateLineJoin(): void {\n    var value: LineJoin = this._stack.reference().lineJoin;\n    if (value != this._currentLineJoin) {\n      this._currentLineJoin = value;\n      super._writeOne(CanvasInstruction.LineJoin, <f64>value);\n    }\n  }\n  //#endregion\n\n  //#region LINEWIDTH\n  /**\n   * A private member that contains a single float value that represents the last lineWidth value\n   * written by a drawing operation.\n   */\n  private _currentLineWidth: f64 = 1.0;\n\n  /**\n   * The CanvasRenderingContext2D.lineWidth property of the Canvas 2D API sets the line dash\n   * offset, or \"phase.\"\n   */\n  public get lineWidth(): f64 {\n    return this._stack.reference().lineWidth;\n  }\n\n  public set lineWidth(value: f64) {\n    if (!isFinite(value) || value < 0) return;\n    this._stack.reference().lineWidth = value;\n  }\n\n  /**\n   * An internal function that writes the current lineWidth value on the _lineWidthStack to the\n   * buffer if it currently does not match the last written lineWidth value.\n   */\n  @inline\n  private _updateLineWidth(): void {\n    var value: f64 = this._stack.reference().lineWidth;\n    if (value != this._currentLineWidth) {\n      this._currentLineWidth = value;\n      super._writeOne(CanvasInstruction.LineWidth, value);\n    }\n  }\n  //#endregion\n\n  //#region MITERLIMIT\n  /**\n   * A private member that contains a single float value that represents the last miterLimit value\n   * written by a drawing operation.\n   */\n  private _currentMiterLimit: f64 = 10.0;\n\n  /**\n   * The CanvasRenderingContext2D.miterLimit property of the Canvas 2D API sets the miter limit\n   * ratio. It establishes a limit on the miter when two lines join at a sharp angle, to let you\n   * control how thick the junction becomes.\n   */\n  public get miterLimit(): f64 {\n    return this._stack.reference().miterLimit;\n  }\n\n  public set miterLimit(value: f64) {\n    if (!isFinite(value) || value < 0) return;\n    this._stack.reference().miterLimit = value;\n  }\n\n  /**\n   * An internal function that writes the current miterLimit value on the _miterLimitStack to the\n   * buffer if it currently does not match the last written miterLimit value.\n   */\n  @inline\n  private _updateMiterLimit(): void {\n    var value: f64 = this._stack.reference().miterLimit;\n    if (value != this._currentMiterLimit) {\n      this._currentMiterLimit = value;\n      super._writeOne(CanvasInstruction.MiterLimit, value);\n    }\n  }\n  //#endregion MITERLIMIT\n\n  //#region SHADOWBLUR\n  /**\n   * A private member that contains a single float value that represents the last shadowBlur value\n   * written by a drawing operation.\n   */\n  private _currentShadowBlur: f64 = 0.0;\n\n  /**\n   * The CanvasRenderingContext2D.shadowBlur property of the Canvas 2D API specifies the amount of\n   * blur applied to shadows. The default is 0 (no blur).\n   *\n   * The shadowBlur value is a non-negative float specifying the level of shadow blur, where 0\n   * represents no blur and larger numbers represent increasingly more blur. This value doesn't\n   * correspond to a number of pixels, and is not affected by the current transformation matrix. The\n   * default value is 0. Negative, Infinity, and NaN values are ignored.\n   */\n  public get shadowBlur(): f64 {\n    return this._stack.reference().shadowBlur;\n  }\n\n  public set shadowBlur(value: f64) {\n    if (!isFinite(value) || value < 0) return;\n    this._stack.reference().shadowBlur = value;\n  }\n\n  /**\n   * An internal function that writes the current shadowBlur value on the _shadowBlurStack to the\n   * buffer if it currently does not match the last written shadowBlur value.\n   */\n  @inline\n  private _updateShadowBlur(): void {\n    var value: f64 = this._stack.reference().shadowBlur;\n    if (value != this._currentShadowBlur) {\n      this._currentShadowBlur = value;\n      super._writeOne(CanvasInstruction.ShadowBlur, value);\n    }\n  }\n  //#endregion SHADOWBLUR\n\n  //#region SHADOWCOLOR\n  /**\n   * A private member that contains a single StrokeShadowColorType value that represents the last\n   * shadowColor value written by a drawing operation\n   */\n  private _currentShadowColor: string = defaultShadowColor;\n\n  /**\n   * The CanvasRenderingContext2D.shadowColor property of the Canvas 2D API specifies the current text\n   * representing a CSS Color\n   */\n  public get shadowColor(): string {\n    return this._stack.reference().shadowColor;\n  }\n\n  public set shadowColor(value: string) {\n    if (value == null) value = defaultShadowColor;\n    var stack = this._stack.reference();\n    __retain(changetype<usize>(value));\n    __release(changetype<usize>(stack.shadowColor));\n    stack.shadowColor = value;\n  }\n\n  /**\n   * An internal function that writes the current shadowColor value on the _shadowColorStack to the\n   * buffer if it currently does not match the last written shadowColor.\n   */\n  @inline\n  private _updateShadowColor(): void {\n    var value: string = this._stack.reference().shadowColor;\n    if (value != this._currentShadowColor) {\n      this._currentFilter = value;\n      super._retain(changetype<usize>(value));\n      super._writeOne(CanvasInstruction.ShadowColor, changetype<usize>(value));\n    }\n  }\n  //#endregion\n\n  //#region SHADOWOFFSETX\n  /**\n   * A private member that contains a single float value that represents the last shadowOffsetX value\n   * written by a drawing operation.\n   */\n  private _currentShadowOffsetX: f64 = 0.0;\n\n  /**\n   * The CanvasRenderingContext2D.shadowOffsetX property of the Canvas 2D API specifies the distance\n   * that shadows will be offset horizontally.\n   *\n   * The value is a f64 specifying the distance that shadows will be offset horizontally. Positive\n   * values are to the right, and negative to the left. The default value is 0 (no horizontal\n   * offset). Infinity and NaN values are ignored.\n   */\n  public get shadowOffsetX(): f64 {\n    return this._stack.reference().shadowOffsetX;\n  }\n\n  public set shadowOffsetX(value: f64) {\n    if (!isFinite(value)) return;\n    this._stack.reference().shadowOffsetX = value;\n  }\n\n  /**\n   * An internal function that writes the current shadowOffsetX value on the _shadowOffsetXStack to the\n   * buffer if it currently does not match the last written shadowOffsetX value.\n   */\n  @inline\n  private _updateShadowOffsetX(): void {\n    var value: f64 = this._stack.reference().shadowOffsetX;\n    if (value != this._currentShadowOffsetX) {\n      this._currentShadowOffsetX = value;\n      super._writeOne(CanvasInstruction.ShadowOffsetX, value);\n    }\n  }\n  //#endregion SHADOWOFFSETX\n\n  //#region SHADOWOFFSETY\n  /**\n   * A private member that contains a single float value that represents the last shadowOffsetY value\n   * written by a drawing operation.\n   */\n  private _currentShadowOffsetY: f64 = 0.0;\n\n  /**\n   * The CanvasRenderingContext2D.shadowOffsetY property of the Canvas 2D API specifies the distance\n   * that shadows will be offset vertically.\n   *\n   * The value is a f64 specifying the distance that shadows will be offset horizontally. Positive\n   * values are down, and negative are up. The default value is 0 (no vertical offset). Infinity and\n   * NaN values are ignored\n   */\n  public get shadowOffsetY(): f64 {\n    return this._stack.reference().shadowOffsetY;\n  }\n\n  public set shadowOffsetY(value: f64) {\n    if (!isFinite(value)) return;\n    this._stack.reference().shadowOffsetY = value;\n  }\n\n  /**\n   * An internal function that writes the current shadowOffsetY value on the _shadowOffsetYStack to the\n   * buffer if it currently does not match the last written shadowOffsetY value.\n   */\n  @inline\n  private _updateShadowOffsetY(): void {\n    var value: f64 = this._stack.reference().shadowOffsetY;\n    if (value != this._currentShadowOffsetY) {\n      this._currentShadowOffsetY = value;\n      super._writeOne(CanvasInstruction.ShadowOffsetY, value);\n    }\n  }\n  //#endregion SHADOWOFFSETY\n\n\n  //#region STROKESTYLE\n  /**\n   * A private member that contains a single StrokeFillStyleType value that represents the last\n   * strokeStyle value written by a drawing operation\n   */\n  private _currentStrokeStyleType: FillStrokeStyleType = FillStrokeStyleType.String;\n\n  /**\n   * A private member that contains a single pointer or id value that represents the last\n   * fillStyle value written by a drawing operation\n   */\n  private _currentStrokeStyleValue: usize = changetype<usize>(defaultBlack);\n\n  /**\n   * The CanvasRenderingContext2D.strokeStyle property of the Canvas 2D API specifies the current text\n   * representing a CSS Color\n   */\n  public get strokeStyle(): string | null {\n    var stack = this._stack.reference();\n    return stack.strokeStyleType === FillStrokeStyleType.String\n      ? stack.strokeStyleString\n      : null;\n  }\n\n  public set strokeStyle(value: string | null) {\n    if (value == null) value = defaultBlack;\n    let stack = this._stack.reference();\n    let currentType = stack.strokeStyleType;\n    stack.strokeStyleType = FillStrokeStyleType.String;\n    __retain(changetype<usize>(value));\n    if (currentType == FillStrokeStyleType.CanvasGradient) {\n      __release(changetype<usize>(stack.strokeStyleGradient));\n      stack.strokeStyleGradient = null;\n    } else if (currentType == FillStrokeStyleType.CanvasPattern) {\n      __release(changetype<usize>(stack.strokeStylePattern));\n      stack.strokeStylePattern = null;\n    } else {\n      __release(changetype<usize>(stack.strokeStyleString));\n    }\n    stack.strokeStyleString = value!;\n    stack.strokeStyleValue = changetype<usize>(value);\n  }\n\n  /**\n   * An internal function that writes the current strokeStyle value on the _strokeStyleStack to the\n   * buffer if it currently does not match the last written strokeStyle.\n   */\n  @inline\n  private _updateStrokeStyle(): void {\n    var stack = this._stack.reference();\n    var styleType = stack.strokeStyleType;\n\n    var pointer: usize = 0;\n    var value: f64 = 0;\n    if (styleType === FillStrokeStyleType.String) {\n      pointer = changetype<usize>(stack.strokeStyleString);\n      value = pointer;\n    } else if (styleType === FillStrokeStyleType.CanvasGradient) {\n      pointer = changetype<usize>(stack.strokeStyleGradient);\n      value = <f64>load<i32>(pointer, offsetof<CanvasGradient>(\"id\"));\n    } else if (styleType === FillStrokeStyleType.CanvasPattern) {\n      pointer = changetype<usize>(stack.strokeStylePattern);\n      value = <f64>load<i32>(pointer, offsetof<CanvasPattern>(\"id\"));\n    }\n\n    if (styleType != this._currentStrokeStyleType || value != this._currentStrokeStyleValue) {\n      var inst: CanvasInstruction;\n      if (styleType == FillStrokeStyleType.String) inst = CanvasInstruction.StrokeStyle;\n      else if (styleType == FillStrokeStyleType.CanvasGradient) inst = CanvasInstruction.StrokeGradient;\n      else inst = CanvasInstruction.StrokePattern;\n      super._retain(pointer);\n      super._writeOne(inst, <f64>value);\n    }\n  }\n  //#endregion STROKESTYLE\n\n  //#region STROKEPATTERN\n  /**\n   * The CanvasRenderingContext2D.strokePattern property of the Canvas 2D API specifies the current\n   * strokeStyle pattern\n   */\n  public get strokePattern(): CanvasPattern | null {\n    var stack = this._stack.reference();\n    return stack.strokeStyleType === FillStrokeStyleType.CanvasPattern\n      ? stack.strokeStylePattern\n      : null;\n  }\n\n  public set strokePattern(value: CanvasPattern | null) {\n    if (value == null) {\n      this.strokeStyle = defaultBlack;\n      return;\n    }\n    __retain(changetype<usize>(value));\n    var stack = this._stack.reference();\n    __release(changetype<usize>(stack.strokeStylePattern));\n    stack.strokeStyleType = FillStrokeStyleType.CanvasPattern;\n    stack.strokeStylePattern = value;\n    stack.strokeStyleValue = <usize>load<i32>(changetype<usize>(value), offsetof<CanvasPattern>(\"id\"));\n  }\n  //#endregion STROKEPATTERN\n\n  //#region STROKEGRADIENT\n  /**\n   * The CanvasRenderingContext2D.strokeGradient property of the Canvas 2D API specifies the current\n   * strokeStyle gradient.\n   */\n  public get strokeGradient(): CanvasGradient | null {\n    var stack = this._stack.reference();\n    return stack.strokeStyleType == FillStrokeStyleType.CanvasGradient\n      ? stack.strokeStyleGradient\n      : null;\n  }\n\n  public set strokeGradient(value: CanvasGradient | null) {\n    if (value == null) {\n      this.strokeStyle = defaultBlack;\n      return;\n    }\n    __retain(changetype<usize>(value));\n    var stack = this._stack.reference();\n    stack.strokeStyleType = FillStrokeStyleType.CanvasGradient;\n    __release(changetype<usize>(stack.strokeStyleGradient));\n    stack.strokeStyleGradient = value;\n    stack.strokeStyleValue = <usize>load<i32>(changetype<usize>(value), offsetof<CanvasGradient>(\"id\"));\n  }\n  //#endregion STROKEGRADIENT\n\n  //#region TEXTALIGN\n  /**\n   * A private member that contains a single LineCap value that represents the last\n   * lineCap value written by a drawing operation.\n   */\n  private _currentTextAlign: TextAlign = TextAlign.start;\n\n  /**\n   * The CanvasRenderingContext2D.textAlign property of the Canvas 2D API specifies the current text\n   * alignment used when drawing text.\n   *\n   * The alignment is relative to the x value of the fillText() method. For example, if textAlign is\n   * \"center\", then the text's left edge will be at x - (textWidth / 2).\n   */\n  public get textAlign(): TextAlign {\n    return this._stack.reference().textAlign;\n  }\n\n  public set textAlign(value: TextAlign) {\n    this._stack.reference().textAlign = value;\n  }\n\n  /**\n   * An internal function that writes the current textAlign value on the _textAlignStack to the\n   * buffer if it currently does not match the last written textAlign value.\n   */\n  @inline\n  private _updateTextAlign(): void {\n    var value: TextAlign = this._stack.reference().textAlign;\n    if (value != this._currentTextAlign) {\n      this._currentTextAlign = value;\n      super._writeOne(CanvasInstruction.TextAlign, <f64>value);\n    }\n  }\n  //#endregion TEXTALIGN\n\n  //#region TEXTBASELINE\n  /**\n   * A private member that contains a single TextBaseline value that represents the last\n   * TextBaseline value written by a drawing operation.\n   */\n  private _currentTextBaseline: TextBaseline = TextBaseline.alphabetic;\n\n  /**\n   * The CanvasRenderingContext2D.textBaseline property of the Canvas 2D API specifies the current\n   * text baseline used when drawing text.\n   */\n  public get textBaseline(): TextBaseline {\n    return this._stack.reference().textBaseline;\n  }\n\n  public set textBaseline(value: TextBaseline) {\n    this._stack.reference().textBaseline = value;\n  }\n\n  /**\n   * An internal function that writes the current textBaseline value on the _textBaselineStack to the\n   * buffer if it currently does not match the last written textBaseline value.\n   */\n  @inline\n  private _updateTextBaseline(): void {\n    var value: TextBaseline = this._stack.reference().textBaseline;\n    if (value != this._currentTextBaseline) {\n      this._currentTextBaseline = value;\n      super._writeOne(CanvasInstruction.TextBaseline, <f64>value);\n    }\n  }\n  //#endregion TEXTBASELINE\n\n  //#region SAVE\n  /**\n   * The CanvasRenderingContext2D.save() method of the Canvas 2D API saves the entire state of the\n   * canvas by pushing the current state onto a stack.\n   *\n   * The drawing state that gets saved onto a stack consists of:\n   *\n   * - The current transformation matrix.\n   * - The current clipping region.\n   * - The current dash list.\n   * - The current values of the following attributes: strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation, font, textAlign, textBaseline, direction, imageSmoothingEnabled.\n   *\n   * @param {bool} hard - Tells the context to perform an actual `save()` operation. Default value is false.\n   */\n  public save(hard: bool = false): void {\n    var offset: i32 = <i32>this._stackOffset;\n    var nextOffset: i32 = offset + 1;\n    if (nextOffset >= <i32>u8.MAX_VALUE) unreachable();\n    let stack = this._stack.push();\n    this._stack = stack;\n    let stackReference = stack.reference();\n    // hard saves\n    stackReference.save = hard;\n\n    // fillStyle\n    __retain(changetype<usize>(stackReference.fillStyleGradient));\n    __retain(changetype<usize>(stackReference.fillStylePattern));\n    __retain(changetype<usize>(stackReference.fillStyleString));\n\n    // filter\n    __retain(changetype<usize>(stackReference.filter));\n\n    // font\n    __retain(changetype<usize>(stackReference.font));\n\n    // lineDash\n    __retain(changetype<usize>(stackReference.lineDash));\n\n    // shadowColor\n    __retain(changetype<usize>(stackReference.shadowColor));\n\n    // strokeStyle\n    __retain(changetype<usize>(stackReference.strokeStyleGradient));\n    __retain(changetype<usize>(stackReference.strokeStylePattern));\n    __retain(changetype<usize>(stackReference.strokeStyleString));\n\n    if (hard) super._writeZero(CanvasInstruction.Save);\n\n    this._stackOffset = <u8>nextOffset;\n  }\n  //#endregion SAVE\n\n  //#region RESTORE\n  /**\n   * The CanvasRenderingContext2D.restore() method of the Canvas 2D API restores the most recently\n   * saved canvas state by popping the top entry in the drawing state stack. If there is no saved\n   * state, this method does nothing.\n   *\n   * In the case of the hard restore, this function will mirror what the browser does, and modifies\n   * the last written values instead of just moving the stack pointer. This ensures that the writer\n   * emulates the browser state machine as accurately as possible.\n   */\n  public restore(): void {\n    if (this._stackOffset == <u8>0) return;\n    let currentStack = this._stack;\n    let nextStack = currentStack.pop();\n    this._stack = nextStack;\n    let currentStackReference = currentStack.reference();\n    let nextStackReference = nextStack.reference();\n    // fillStyle\n    __release(changetype<usize>(currentStackReference.fillStyleGradient));\n    __release(changetype<usize>(currentStackReference.fillStylePattern));\n    __release(changetype<usize>(currentStackReference.fillStyleString));\n\n    // filter\n    __release(changetype<usize>(currentStackReference.filter));\n\n    // font\n    __release(changetype<usize>(currentStackReference.font));\n\n    // lineDash\n    __release(changetype<usize>(currentStackReference.lineDash));\n\n    // shadowColor\n    __release(changetype<usize>(currentStackReference.shadowColor));\n\n    // strokeStyle\n    __release(changetype<usize>(currentStackReference.strokeStyleGradient));\n    __release(changetype<usize>(currentStackReference.strokeStylePattern));\n    __release(changetype<usize>(currentStackReference.strokeStyleString));\n\n\n    if (currentStackReference.save) {\n      super._writeZero(CanvasInstruction.Restore);\n\n      // currentTransform\n      memory.copy(\n        changetype<usize>(this._currentTransform),\n        changetype<usize>(nextStackReference) + offsetof<CanvasStack>(\"a\"),\n        48,\n      );\n\n      this._currentDirection = nextStackReference.direction;\n\n      this._currentFillStyleType = nextStackReference.fillStyleType;\n      this._currentFillStyleValue = <usize>nextStackReference.fillStyleValue;\n\n      this._currentFilter = nextStackReference.filter;\n\n      this._currentFont = nextStackReference.font;\n\n      this._currentGlobalAlpha = nextStackReference.globalAlpha;\n      this._currentGlobalCompositeOperation = nextStackReference.globalCompositeOperation;\n\n      this._currentImageSmoothingEnabled = nextStackReference.imageSmoothingEnabled;\n      this._currentImageSmoothingQuality = nextStackReference.imageSmoothingQuality;\n\n      this._currentLineCap = nextStackReference.lineCap;\n      this._currentLineDash = nextStackReference.lineDash;\n      this._currentLineJoin = nextStackReference.lineJoin;\n      this._currentLineWidth = nextStackReference.lineWidth;\n      this._currentMiterLimit = nextStackReference.miterLimit;\n\n      this._currentShadowBlur = nextStackReference.shadowBlur;\n      this._currentShadowColor = nextStackReference.shadowColor;\n      this._currentShadowOffsetX = nextStackReference.shadowOffsetX;\n      this._currentShadowOffsetY = nextStackReference.shadowOffsetY;\n\n      this._currentStrokeStyleType = nextStackReference.strokeStyleType;\n      this._currentStrokeStyleValue = <usize>nextStackReference.strokeStyleValue;\n\n      this._currentTextAlign = nextStackReference.textAlign;\n      this._currentTextBaseline = nextStackReference.textBaseline;\n    }\n\n    this._stackOffset -= <u8>1;\n  }\n  //#endregion RESTORE\n\n  //#region PATH\n  /**\n   * A c like pointer that always points to the next path element to write to.\n   */\n  private _path: StackPointer<Path2DElement> = createPathElements().increment();\n\n  /**\n   * A reference to the path start for quick path resetting.\n   */\n  private _pathStart: StackPointer<Path2DElement> = this._path.decrement();\n\n  /**\n   * A pointer that points to the end of the path.\n   */\n  private _pathEnd: StackPointer<Path2DElement> =\n    changetype<StackPointer<Path2DElement>>(changetype<usize>(this._pathStart) + offsetof<Path2DElement>() * 0x1000);\n\n  /**\n   * A reference to the next path item that should be written to the buffer.\n   */\n  private _pathCurrent: StackPointer<Path2DElement> = this._pathStart;\n\n  /**\n   * An internal function that writes a single path item to the _path.\n   *\n   * @param {CanvasInstruction} inst - The CanvasInstruction that represents the current pathing\n   * operation that should be written to the path buffer.\n   * @param {bool} updateTransform - The bool value that determines if the PathElement should store\n   * the _currentTransform values.\n   * @param {i32} count - The number of parameters for this PathElement's instruction.\n   * @param {f64} a - The first parameter for this PathElement's instruction.\n   * @param {f64} b - The second parameter for this PathElement's instruction.\n   * @param {f64} c - The third parameter for this PathElement's instruction.\n   * @param {f64} d - The fourth parameter for this PathElement's instruction.\n   * @param {f64} e - The five parameter for this PathElement's instruction.\n   * @param {f64} f - The six parameter for this PathElement's instruction.\n   * @param {f64} g - The seven parameter for this PathElement's instruction.\n   * @param {f64} h - The eighth parameter for this PathElement's instruction.\n   */\n  @inline\n  private _writePath(\n    inst: CanvasInstruction,\n    updateTransform: bool = false,\n    count: i32 = 0,\n    a: f64 = 0.0,\n    b: f64 = 0.0,\n    c: f64 = 0.0,\n    d: f64 = 0.0,\n    e: f64 = 0.0,\n    f: f64 = 0.0,\n    g: f64 = 0.0,\n    h: f64 = 0.0,\n  ): void {\n    let _path = this._path;\n    let element = _path.reference();\n    assert(changetype<usize>(_path) < changetype<usize>(this._pathEnd));\n    element.instruction = inst;\n    element.updateTransform = updateTransform;\n    if (updateTransform) {\n      let current = this._stack.reference();\n      element.transformA = current.a;\n      element.transformB = current.b;\n      element.transformC = current.c;\n      element.transformD = current.d;\n      element.transformE = current.e;\n      element.transformF = current.f;\n    }\n    element.count = count;\n    element.a = a;\n    element.b = b;\n    element.c = c;\n    element.d = d;\n    element.e = e;\n    element.f = f;\n    element.g = g;\n    element.h = h;\n    this._path = _path.increment();\n  }\n\n  /**\n   * An internal function that writes the queued up path items to the buffer. It optionally calls\n   * setTransform if the transform was modified between path calls.\n   */\n  @inline\n  private _updatePath(): void {\n    var nextPath = this._path;\n    var el: Path2DElement;\n    var a: f64;\n    var b: f64;\n    var c: f64;\n    var d: f64;\n    var e: f64;\n    var f: f64;\n    var currentTransform: usize = changetype<usize>(this._currentTransform);\n    var currentPath = this._pathCurrent;\n    while (currentPath.dereference() < nextPath.dereference()) {\n      el = currentPath.reference();\n      if (el.updateTransform) {\n        a = el.transformA;\n        b = el.transformB;\n        c = el.transformC;\n        d = el.transformD;\n        e = el.transformE;\n        f = el.transformF;\n\n        let diff = memory.compare(\n          currentTransform,\n          changetype<usize>(el) + offsetof<Path2DElement>(\"transformA\"),\n          48,\n        );\n        if (diff != 0) {\n          super._writeSix(CanvasInstruction.SetTransform, a, b, c, d, e, f);\n          STORE<f64>(currentTransform, 0, a);\n          STORE<f64>(currentTransform, 1, b);\n          STORE<f64>(currentTransform, 2, c);\n          STORE<f64>(currentTransform, 3, d);\n          STORE<f64>(currentTransform, 4, e);\n          STORE<f64>(currentTransform, 5, f);\n        }\n      }\n      switch (el.count) {\n        case 0: {\n          super._writeZero(el.instruction);\n          break;\n        }\n        case 1: {\n          super._writeOne(el.instruction, el.a);\n          break;\n        }\n        case 2: {\n          super._writeTwo(el.instruction, el.a, el.b);\n          break;\n        }\n        case 4: {\n          super._writeFour(el.instruction, el.a, el.b, el.c, el.d);\n          break;\n        }\n        case 5: {\n          super._writeFive(el.instruction, el.a, el.b, el.c, el.d, el.e);\n          break;\n        }\n        case 6: {\n          super._writeSix(el.instruction, el.a, el.b, el.c, el.d, el.e, el.f);\n          break;\n        }\n        case 8: {\n          super._writeEight(el.instruction, el.a, el.b, el.c, el.d, el.e, el.f, el.g, el.h);\n        }\n      }\n      currentPath = currentPath.increment();\n    }\n    this._pathCurrent = currentPath;\n  }\n  //#endregion PATH\n\n  //#region ARC\n  /**\n   * The CanvasRenderingContext2D.arc() method of the Canvas 2D API adds a circular arc to\n   * the current sub-path.\n   *\n   * @param {f64} x - The x-axis (horizontal) coordinate of the arc's center.\n   * @param {f64} y - The y-axis (vertical) coordinate of the arc's center.\n   * @param {f64} radius - The arc's radius. Must be non-negative.\n   * @param {f64} startAngle - The angle at which the arc starts, measured clockwise from the positive x-axis\n   * and expressed in radians.\n   * @param {f64} endAngle - The angle at which the arc ends, measured clockwise from the positive x-axis and\n   * expressed in radians.\n   * @param {bool} anticlockwise - An optional bool which, if true, causes the arc to be drawn\n   * counter-clockwise between the start and end angles. The default value is false (clockwise).\n   */\n  public arc(x: f64, y: f64, radius: f64, startAngle: f64, endAngle: f64 , anticlockwise: bool = false): void {\n    if (!isFinite(x + y + radius + startAngle + endAngle) || radius < 0) return;\n    this._writePath(CanvasInstruction.Arc, true, 6, x, y, radius, startAngle, endAngle, anticlockwise ? 1.0 : 0.0);\n  }\n  //#endregion ARC\n\n  //#region ARCTO\n  /**\n   * The CanvasRenderingContext2D.arcTo() method of the Canvas 2D API adds a circular arc to the current\n   * sub-path, using the given control points and radius. The arc is automatically connected to the\n   * path's latest point with a straight line, if necessary for the specified parameters. This method is\n   * commonly used for making rounded corners.\n   *\n   * @param {f64} x1 - The x-axis coordinate of the first control point.\n   * @param {f64} y1 - The y-axis coordinate of the first control point.\n   * @param {f64} x2 - The x-axis coordinate of the second control point.\n   * @param {f64} y2 - The y-axis coordinate of the second control point.\n   * @param {f64} radius - The arc's radius. Must be non-negative.\n   */\n  public arcTo(x1: f64, y1: f64, x2: f64, y2: f64, radius: f64): void {\n    if (!isFinite(x1 + y1 + x2 + y2 + radius) || radius < 0) return;\n    this._writePath(CanvasInstruction.ArcTo, true, 5, x1, y1, x2, y2, radius);\n  }\n  //#endregion ARCTO\n\n  //#region BEGINPATH\n  /**\n   * The CanvasRenderingContext2D.beginPath() method of the Canvas 2D API starts a new path by\n   * emptying the list of sub-paths. Call this method when you want to create a new path.\n   */\n  public beginPath(): void {\n    let start = this._pathStart;\n    this._path = start.increment();\n    this._pathCurrent = start;\n  }\n  //#endregion BEGINPATH\n\n  //#region BEZIERCURVETO\n  /**\n   * The CanvasRenderingContext2D.bezierCurveTo() method of the Canvas 2D API adds a cubic Bézier\n   * curve to the current sub-path. It requires three points: the first two are control points and\n   * the third one is the end point. The starting point is the latest point in the current path, which\n   * can be changed using moveTo() before creating the Bézier curve.\n   *\n   * @param {f64} cp1x - The x-axis coordinate of the first control point.\n   * @param {f64} cp1y - The y-axis coordinate of the first control point.\n   * @param {f64} cp2x - The x-axis coordinate of the second control point.\n   * @param {f64} cp2y - The y-axis coordinate of the second control point.\n   * @param {f64} x - The x-axis coordinate of the end point.\n   * @param {f64} y - The y-axis coordinate of the end point.\n   */\n  public bezierCurveTo(cp1x: f64, cp1y: f64, cp2x: f64, cp2y: f64, x: f64, y: f64): void {\n    if (!isFinite(cp1x + cp1y + cp2x + cp2y + x + y)) return;\n    this._writePath(CanvasInstruction.BezierCurveTo, true, 6, cp1x, cp1y, cp2x, cp2y, x, y);\n  }\n  //#endregion BEZIERCURVETO\n\n  //#region CLEARRECT\n  /**\n   * The CanvasRenderingContext2D.clearRect() method of the Canvas 2D API erases the pixels in a\n   * rectangular area by setting them to transparent black.\n   *\n   * @param {f64} x - The x-axis coordinate of the rectangle's starting point.\n   * @param {f64} y - The y-axis coordinate of the rectangle's starting point.\n   * @param {f64} width - The rectangle's width. Positive values are to the right, and negative to\n   * the left.\n   * @param {f64} height - The rectangle's height. Positive values are down, and negative are up.\n   */\n  public clearRect(x: f64, y: f64, width: f64, height: f64): void {\n    if (!isFinite(x + y + width + height)) return;\n    this._updateTransform();\n    super._writeFour(CanvasInstruction.ClearRect, x, y, width, height);\n  }\n  //#endregion CLEARRECT\n\n  //#region CLIP\n  /**\n   * The CanvasRenderingContext2D.clip() method of the Canvas 2D API turns the current or given path\n   * into the current clipping region. It replaces any previous clipping region. In the image below,\n   * the red outline represents a clipping region shaped like a star. Only those parts of the\n   * checkerboard pattern that are within the clipping region get drawn.\n   */\n  public clip(): void {\n    this._updatePath();\n    super._writeZero(CanvasInstruction.Clip);\n  }\n  //#endregion CLIP\n\n  //#region CLOSEPATH\n  /**\n   * The CanvasRenderingContext2D.closePath() method of the Canvas 2D API attempts to add a straight\n   * line from the current point to the start of the current sub-path. If the shape has already been\n   * closed or has only one point, this function does nothing. This method doesn't draw anything to\n   * the canvas directly. You can render the path using the stroke() or fill() methods.\n   */\n  public closePath(): void {\n    let previous = this._path.decrement().reference();\n    if (i32(previous.instruction == CanvasInstruction.BeginPath) | i32(previous.instruction == CanvasInstruction.ClosePath)) return;\n    this._writePath(CanvasInstruction.ClosePath, true, 0);\n  }\n\n  //#endregion CLOSEPATH\n\n  //#region DRAWIMAGE\n  /**\n   * The CanvasRenderingContext2D.drawImagePosition() method of the Canvas 2D API provides a simple\n   * method for drawing an image onto the canvas at a specific position.\n   *\n   * @param {Image} image - An element to draw into the context. The specification permits any canvas\n   * image source (Image).\n   * @param {f64} dx - The x-axis coordinate in the destination canvas at which to place the top-left\n   * corner of the source image.\n   * @param {f64} dy - The y-axis coordinate in the destination canvas at which to place the top-left\n   * corner of the source image.\n   */\n  public drawImage(image: Image | null, dx: f64, dy: f64): void {\n    if (image == null || !isFinite(dx + dy) || !image.loaded) return;\n    this._updateFilter();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateTransform();\n    this._writeNine(\n      CanvasInstruction.DrawImage,\n      <f64>getImageID(image),\n      0.0, 0.0, <f64>image.width, <f64>image.height,\n      dx, dy, <f64>image.width, <f64>image.height,\n    );\n  }\n\n  /**\n   * The CanvasRenderingContext2D.drawImageSize() method of the Canvas 2D API provides a simple\n   * method for drawing an image onto the canvas at a specific position.\n   *\n   * @param {Image} image - An element to draw into the context. The specification permits any canvas\n   * image source (Image).\n   * @param {f64} dx - The x-axis coordinate in the destination canvas at which to place the top-left\n   * corner of the source image.\n   * @param {f64} dy - The y-axis coordinate in the destination canvas at which to place the top-left\n   * corner of the source image.\n   * @param {f64} dWidth - The width to draw the image in the destination canvas. This allows scaling\n   * of the drawn image. If not specified, the image is not scaled in width when drawn.\n   * @param {f64} dHeight - The height to draw the image in the destination canvas. This allows scaling\n   * of the drawn image. If not specified, the image is not scaled in height when drawn.\n   */\n  public drawImageSize(image: Image | null, dx: f64, dy: f64, dWidth: f64, dHeight: f64): void {\n    if (image == null || !isFinite(dx + dy + dWidth + dHeight) || !image.loaded) return;\n    this._updateFilter();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateTransform();\n    this._writeNine(\n      CanvasInstruction.DrawImage,\n      <f64>getImageID(image),\n      0.0, 0.0, <f64>image.width, <f64>image.height,\n      dx, dy, dWidth, dHeight,\n    );\n  }\n\n  /**\n   * The CanvasRenderingContext2D.drawImageSource() method of the Canvas 2D API provides a simple\n   * method for drawing an image onto the canvas at a specific position.\n   *\n   * @param {Image} image - An element to draw into the context. The specification permits any canvas\n   * image source (Image).\n   * @param {f64} sx - The x-axis coordinate of the top left corner of the sub-rectangle of the source\n   * image to draw into the destination context.\n   * @param {f64} sy - The y-axis coordinate of the top left corner of the sub-rectangle of the source\n   * image to draw into the destination context.\n   * @param {f64} sWidth - The width of the sub-rectangle of the source image to draw into the\n   * destination context. If not specified, the entire rectangle from the coordinates specified by sx\n   * and sy to the bottom-right corner of the image is used.\n   * @param {f64} sHeight - The height of the sub-rectangle of the source image to draw into the\n   * destination context.\n   * @param {f64} dx - The x-axis coordinate in the destination canvas at which to place the top-left\n   * corner of the source image.\n   * @param {f64} dy - The y-axis coordinate in the destination canvas at which to place the top-left\n   * corner of the source image.\n   * @param {f64} dWidth - The width to draw the image in the destination canvas. This allows scaling\n   * of the drawn image. If not specified, the image is not scaled in width when drawn.\n   * @param {f64} dHeight - The height to draw the image in the destination canvas. This allows scaling\n   * of the drawn image. If not specified, the image is not scaled in height when drawn.\n   */\n  public drawImageSource(image: Image | null, sx: f64, sy: f64, sWidth: f64, sHeight: f64, dx: f64, dy: f64, dWidth: f64, dHeight: f64): void {\n    if (image == null || !isFinite(sx + sy + sWidth + sHeight + dx + dy + dWidth + dHeight) || !image.loaded) return;\n    this._updateFilter();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateTransform();\n    this._writeNine(\n      CanvasInstruction.DrawImage,\n      <f64>getImageID(image),\n      sx, sy, sWidth, sHeight,\n      dx, dy, dWidth, dHeight,\n    );\n  }\n  //#endregion DRAWIMAGE\n\n  //#region ELLIPSE\n  /**\n   * The CanvasRenderingContext2D.ellipse() method of the Canvas 2D API adds an elliptical arc to the current sub-path.\n   *\n   * @param {f64} x - The x-axis (horizontal) coordinate of the ellipse's center.\n   * @param {f64} y - The y-axis (vertical) coordinate of the ellipse's center.\n   * @param {f64} radiusX - The ellipse's major-axis radius. Must be non-negative.\n   * @param {f64} radiusY - The ellipse's minor-axis radius. Must be non-negative.\n   * @param {f64} rotation - The rotation of the ellipse, expressed in radians.\n   * @param {f64} startAngle - The angle at which the ellipse starts, measured clockwise from the positive x-axis\n   * and expressed in radians.\n   * @param {f64} endAngle - The angle at which the ellipse ends, measured clockwise from the positive x-axis and\n   * expressed in radians.\n   * @param {bool} anticlockwise - An optional Boolean which, if true, draws the ellipse anticlockwise\n   * (counter-clockwise). The default value is false (clockwise).\n   */\n  public ellipse(x: f64, y: f64, radiusX: f64, radiusY: f64, rotation: f64, startAngle: f64, endAngle: f64, anticlockwise: bool = false): void {\n    if (!isFinite(x + y + radiusX + radiusY + rotation + startAngle + endAngle) || radiusX < 0 || radiusY < 0) return;\n    this._writePath(\n      CanvasInstruction.Ellipse,\n      true, 8,\n      x, y, radiusX, radiusY,\n      rotation, startAngle, endAngle, anticlockwise ? 1.0 : 0.0,\n    );\n  }\n  //#endregion ELLIPSE\n\n  //#region FILL\n  /**\n   * The CanvasRenderingContext2D.fill() method of the Canvas 2D API fills the current or given path\n   * with the current fillStyle.\n   *\n   * @param {FillRule} fillRule - The algorithm by which to determine if a point is inside or\n   * outside the filling region.\n   *\n   * Possible values:\n   * - `FillRule.nonzero`: The non-zero winding rule. Default rule.\n   * - `FillRule.evenodd`: The even-odd winding rule.\n   */\n  public fill(fillRule: FillRule = FillRule.nonzero): void {\n    /**\n     * If there are no items on the path, there is no reason to fill. Index 1 means the path buffer\n     * is pointing to a single `beginPath()` operation and it does not matter if fill is called at\n     * this point.\n     */\n    if (this._path == this._pathStart.increment()) return;\n    this._updateFillStyle();\n    this._updateFilter();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n\n    /**\n     * This function must be called *before* _updateTransform(), because both the path operations and the\n     * fill operations affect the transform. Each pathing operation has it's own transform, and the\n     * transform value when the fill operation occurs might be different.\n     */\n    this._updatePath();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateTransform();\n    super._writeOne(CanvasInstruction.Fill, <f64>fillRule);\n  }\n  //#endregion FILL\n\n  //#region FILLRECT\n  /**\n   * The CanvasRenderingContext2D.fillRect() method of the Canvas 2D API draws a rectangle that is\n   * filled according to the current fillStyle. This method draws directly to the canvas without\n   * modifying the current path, so any subsequent fill() or stroke() calls will have no effect on\n   * it.\n   *\n   * @param x - The x-axis coordinate of the rectangle's starting point.\n   * @param y - The y-axis coordinate of the rectangle's starting point.\n   * @param width - The rectangle's width. Positive values are to the right, and negative to the\n   * left.\n   * @param height - The rectangle's height. Positive values are down, and negative are up.\n   */\n  public fillRect(x: f64, y: f64, width: f64, height: f64): void {\n    if (!isFinite(x + y + width + height)) return;\n    this._updateFillStyle();\n    this._updateFilter();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateTransform();\n    super._writeFour(CanvasInstruction.FillRect, x, y, width, height);\n  }\n  //#endregion FILLRECT\n\n  //#region FILLTEXT\n  /**\n   * The CanvasRenderingContext2D method fillText(), part of the Canvas 2D API, draws a text string\n   * at the specified coordinates, filling the string's characters with the current fillStyle. An\n   * optional parameter allows specifying a maximum width for the rendered text, which the user\n   * agent will achieve by condensing the text or by using a lower font size. This method draws\n   * directly to the canvas without modifying the current path, so any subsequent fill() or stroke()\n   * calls will have no effect on it. The text is rendered using the font and text layout\n   * configuration as defined by the font, textAlign, textBaseline, and direction properties.\n   *\n   * The fillText function can accept an optional maxWidth property. Use the fillTextWidth function\n   * to enable the use of that parameter.\n   *\n   * @param text - A DOMString specifying the text string to render into the context. The text is\n   * rendered using the settings specified by font, textAlign, textBaseline, and direction.\n   * @param x - The x-axis coordinate of the point at which to begin drawing the text, in pixels.\n   * @param y - The y-axis coordinate of the point at which to begin drawing the text, in pixels.\n   */\n  public fillText(text: string, x: f64, y: f64): void {\n    if (!isFinite(x + y) || text == null || text.length == 0) return;\n    this._updateDirection();\n    this._updateFillStyle();\n    this._updateFilter();\n    this._updateFont();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateTextAlign();\n    this._updateTextBaseline();\n    this._updateTransform();\n    super._retain(changetype<usize>(text));\n    super._writeThree(CanvasInstruction.FillText, <f64>changetype<usize>(text), x, y);\n  }\n\n  /**\n   * The CanvasRenderingContext2D method fillText(), part of the Canvas 2D API, draws a text string\n   * at the specified coordinates, filling the string's characters with the current fillStyle. An\n   * optional parameter allows specifying a maximum width for the rendered text, which the user\n   * agent will achieve by condensing the text or by using a lower font size. This method draws\n   * directly to the canvas without modifying the current path, so any subsequent fill() or stroke()\n   * calls will have no effect on it. The text is rendered using the font and text layout\n   * configuration as defined by the font, textAlign, textBaseline, and direction properties.\n   *\n   * The fillText function can accept an optional maxWidth property. Use the fillTextWidth function\n   * to enable the use of that parameter.\n   *\n   * @param text - A DOMString specifying the text string to render into the context. The text is\n   * rendered using the settings specified by font, textAlign, textBaseline, and direction.\n   * @param x - The x-axis coordinate of the point at which to begin drawing the text, in pixels.\n   * @param y - The y-axis coordinate of the point at which to begin drawing the text, in pixels.\n   * @param maxWidth - The maximum number of pixels wide the text may be once rendered. If not\n   * specified, there is no limit to the width of the text. However, if this value is provided, the\n   * user agent will adjust the kerning, select a more horizontally condensed font (if one is available or can be generated without loss of quality), or scale down to a smaller font size in order to fit the text in the specified width.\n   */\n  public fillTextWidth(text: string, x: f64, y: f64, maxWidth: f64): void {\n    if (!isFinite(x + y + maxWidth) || text == null || text.length == 0 || maxWidth < 0) return;\n    this._updateDirection();\n    this._updateFillStyle();\n    this._updateFilter();\n    this._updateFont();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateTextAlign();\n    this._updateTextBaseline();\n    this._updateTransform();\n    super._retain(changetype<usize>(text));\n    super._writeFour(CanvasInstruction.FillTextWidth, <f64>changetype<usize>(text), x, y, maxWidth);\n  }\n  //#endregion FILLTEXT\n\n  //#region ISPOINTINPATH\n  /**\n   * The CanvasRenderingContext2D.isPointInPath() method of the Canvas 2D API reports whether or not\n   * the specified point is contained in the current path. It forces a commit to flush all the\n   * current instructions to the buffer, updates the path, and then performs a pointInPath function\n   * call on the canvas.\n   *\n   * @param {f64} x - The x-axis coordinate of the point to check.\n   * @param {f64} y - The y-axis coordinate of the point to check.\n   * @param {FillRule} fillRule - The algorithm by which to determine if a point is inside or\n   * outside the path.\n   *\n   * Possible values:\n   * - `FillRule.nonzero`: The non-zero winding rule. Default rule.\n   * - `FillRule.evenodd`: The even-odd winding rule.\n   */\n  public isPointInPath(x: f64, y: f64, fillRule: FillRule = FillRule.nonzero): bool {\n    if (!isFinite(x + y)) return false;\n    this._updatePath();\n    this.commit();\n    return isPointInPath(this.id, x, y, fillRule);\n  }\n  //#endregion ISPOINTINPATH\n\n  //#region ISPOINTINSTROKE\n  /**\n   * The CanvasRenderingContext2D.isPointInStroke() method of the Canvas 2D API reports whether or\n   * not the specified point is inside the area contained by the stroking of a path. It forces a\n   * commit to flush all the current instructions to the buffer, updates the path, and then performs\n   * a pointInPath function call on the canvas.\n   *\n   * @param {f64} x - The x-axis coordinate of the point to check.\n   * @param {f64} y - The y-axis coordinate of the point to check.\n   */\n  public isPointInStroke(x: f64, y: f64): bool {\n    if (!isFinite(x + y)) return false;\n    this._updatePath();\n    this.commit();\n    return isPointInStroke(this.id, x, y);\n  }\n  //#endregion ISPOINTINSTROKE\n\n  //#region LINETO\n  /**\n   * The CanvasRenderingContext2D method lineTo(), part of the Canvas 2D API, adds a straight line\n   * to the current sub-path by connecting the sub-path's last point to the specified (x, y)\n   * coordinates. Like other methods that modify the current path, this method does not directly\n   * render anything. To draw the path onto a canvas, you can use the fill() or stroke() methods.\n   *\n   * @param {f64} x - The x-axis coordinate of the line's end point.\n   * @param {f64} y - The y-axis coordinate of the line's end point.\n   */\n  public lineTo(x: f64, y: f64): void {\n    if (!isFinite(x + y)) return;\n    this._writePath(CanvasInstruction.LineTo, true, 2, x, y);\n  }\n  //#endregion LINETO\n\n  //#region MEASURETEXT\n  /**\n   * The CanvasRenderingContext2D.measureText() method returns a TextMetrics object that contains\n   * information about the measured text (such as its width, for example). The as2d implementation\n   * only returns the resulting width property value.\n   *\n   * @param {string} text - The text string to measure.\n   */\n  public measureText(text: string): f64 {\n    this._updateFont();\n    this.commit();\n    return measureText(this.id, text);\n  }\n  //#endregion MEASURETEXT\n\n  //#region MOVETO\n  /**\n   * The CanvasRenderingContext2D.moveTo() method of the Canvas 2D API begins a new sub-path at the\n   * point specified by the given (x, y) coordinates.\n   *\n   * @param {f64} x - The x-axis (horizontal) coordinate of the point.\n   * @param {f64} y - The y-axis (vertical) coordinate of the point.\n   */\n  public moveTo(x: f64, y: f64): void {\n    if (!isFinite(x + y)) return;\n    this._writePath(CanvasInstruction.MoveTo, true, 2, x, y);\n  }\n  //#endregion MOVETO\n\n  //#region QUADRATICCURVETO\n  /**\n   * The CanvasRenderingContext2D.quadraticCurveTo() method of the Canvas 2D API adds a quadratic\n   * Bézier curve to the current sub-path. It requires two points: the first one is a control point\n   * and the second one is the end point. The starting point is the latest point in the current\n   * path, which can be changed using moveTo() before creating the quadratic Bézier curve.\n   *\n   * @param cpx - The x-axis coordinate of the control point.\n   * @param cpy - The y-axis coordinate of the control point.\n   * @param x - The x-axis coordinate of the end point.\n   * @param y - The y-axis coordinate of the end point.\n   */\n  public quadraticCurveTo(cpx: f64, cpy: f64, x: f64, y: f64): void {\n    if (!isFinite(cpx + cpy + x + y)) return;\n    this._writePath(CanvasInstruction.QuadraticCurveTo, true, 4, cpx, cpy, x, y);\n  }\n  //#endregion QUADRATICCURVETO\n\n  //#region RECT\n  /**\n   * The CanvasRenderingContext2D.rect() method of the Canvas 2D API adds a rectangle to the current\n   * path. Like other methods that modify the current path, this method does not directly render\n   * anything. To draw the rectangle onto a canvas, you can use the fill() or stroke() methods.\n   *\n   * @param {f64} x - The x-axis coordinate of the rectangle's starting point.\n   * @param {f64} y - The y-axis coordinate of the rectangle's starting point.\n   * @param {f64} width - The rectangle's width. Positive values are to the right, and negative to\n   * the left.\n   * @param {f64} height - The rectangle's height. Positive values are down, and negative are up.\n   */\n  public rect(x: f64, y: f64, width: f64, height: f64): void {\n    if (!isFinite(x + y + width + height)) return;\n    this._writePath(CanvasInstruction.Rect, true, 4, x, y, width, height);\n  }\n  //#endregion RECT\n\n  //#region RESETTRANSFORM\n  /**\n   * The CanvasRenderingContext2D.resetTransform() method of the Canvas 2D API resets the current\n   * transform to the identity matrix.\n   */\n  public resetTransform(): void {\n    this.setTransform(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);\n  }\n  //#endregion RESETTRANSFORM\n\n  //#region ROTATE\n  /**\n   * The CanvasRenderingContext2D.rotate() method of the Canvas 2D API adds a rotation to the\n   * transformation matrix.\n   *\n   * @param {f64} angle - The rotation angle, clockwise in radians. You can use\n   * `degree * Math.PI / 180` if you want to calculate from a degree value.\n   */\n  public rotate(angle: f64): void {\n    if (!isFinite(angle)) return;\n\n    NativeMath.sincos(angle);\n    var cos: f64 = NativeMath.sincos_cos;\n    var sin: f64 = NativeMath.sincos_sin;\n\n    if (ASC_FEATURE_SIMD) {\n      let stack = this._stack.dereference();\n      let cossplat = v128.splat<f64>(cos);\n      let sinsplat = v128.splat<f64>(sin);\n      let ab = v128.load(stack, offsetof<CanvasStack>(\"a\"));\n      let cb = v128.load(stack, offsetof<CanvasStack>(\"c\"));\n      v128.store(stack,\n        v128.add<f64>(\n          v128.mul<f64>(ab, cossplat),\n          v128.mul<f64>(cb, sinsplat),\n        ),\n        offsetof<CanvasStack>(\"a\"),\n      );\n      v128.store(stack,\n        v128.sub<f64>(\n          v128.mul<f64>(cb, cossplat),\n          v128.mul<f64>(ab, sinsplat),\n        ),\n        offsetof<CanvasStack>(\"c\"),\n      );\n    } else {\n      var stack = this._stack.reference();\n      var a = stack.a;\n      var b = stack.b;\n      var c = stack.c;\n      var d = stack.d;\n      stack.a = a * cos + c * sin;\n      stack.b = b * cos + d * sin;\n      stack.c = c * cos - a * sin;\n      stack.d = d * cos - b * sin;\n    }\n  }\n  //#endregion ROTATE\n\n  //#region SCALE\n  /**\n   * The CanvasRenderingContext2D.scale() method of the Canvas 2D API adds a scaling transformation\n   * to the canvas units horizontally and/or vertically. By default, one unit on the canvas is\n   * exactly one pixel. A scaling transformation modifies this behavior. For instance, a scaling\n   * factor of 0.5 results in a unit size of 0.5 pixels; shapes are thus drawn at half the normal\n   * size. Similarly, a scaling factor of 2.0 increases the unit size so that one unit becomes two\n   * pixels; shapes are thus drawn at twice the normal size.\n   *\n   * @param {f64} x - Scaling factor in the horizontal direction. A negative value flips pixels\n   * across the vertical axis. A value of 1 results in no horizontal scaling.\n   * @param {f64} y - Scaling factor in the vertical direction. A negative value flips pixels across\n   * the horizontal axis. A value of 1 results in no vertical scaling.\n   */\n  public scale(x: f64, y: f64): void {\n    if (!isFinite(x + y)) return;\n    if (ASC_FEATURE_SIMD) {\n      let stack = this._stack.dereference();\n      v128.store(stack,\n        v128.mul<f64>(\n          v128.load(stack, offsetof<CanvasStack>(\"a\")),\n          v128.splat<f64>(x),\n        ),\n        offsetof<CanvasStack>(\"a\"),\n      );\n      v128.store(stack,\n        v128.mul<f64>(\n          v128.load(stack, offsetof<CanvasStack>(\"c\")),\n          v128.splat<f64>(y),\n        ),\n        offsetof<CanvasStack>(\"c\"),\n      );\n    } else {\n      let stack = this._stack.reference();\n      stack.a *= x;\n      stack.b *= x;\n      stack.c *= y;\n      stack.d *= y;\n    }\n  }\n  //#endregion SCALE\n\n  //#region SETTRANSFORM\n  /**\n   * The CanvasRenderingContext2D.setTransform() method of the Canvas 2D API resets (overrides) the\n   * current transformation to the identity matrix, and then invokes a transformation described by\n   * the arguments of this method. This lets you scale, rotate, translate (move), and skew the\n   * context.\n   *\n   * @param {f64} a - Horizontal scaling. A value of 1 results in no scaling.\n   * @param {f64} b - Vertical skewing.\n   * @param {f64} c - Horizontal skewing.\n   * @param {f64} d - Vertical scaling. A value of 1 results in no scaling.\n   * @param {f64} e - Horizontal translation (moving).\n   * @param {f64} f - Vertical translation (moving).\n   */\n  public setTransform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\n    if (!isFinite(a + b + c + d + e + f)) return ;\n    let stack = this._stack.reference();\n    stack.a = a;\n    stack.b = b;\n    stack.c = c;\n    stack.d = d;\n    stack.e = e;\n    stack.f = f;\n  }\n  //#endregion SETTRANSFORM\n\n  //#region STROKE\n  /**\n   * The CanvasRenderingContext2D.stroke() method of the Canvas 2D API strokes (outlines) the\n   * current or given path with the current stroke style. Strokes are aligned to the center of a\n   * path; in other words, half of the stroke is drawn on the inner side, and half on the outer\n   * side. The stroke is drawn using the non-zero winding rule, which means that path intersections\n   * will still get filled.\n   */\n  public stroke(): void {\n    /**\n     * If there are no items on the path, there is no reason to fill. Index 1 means the path buffer\n     * is pointing to a single `beginPath()` operation and it does not matter if fill is called at\n     * this point.\n     */\n    if (this._path == this._pathStart.increment()) return;\n\n    /**\n     * If the lineWidth is zero, there is no line and it does not matter if ctx.stroke() is called.\n     */\n    if (this._stack.reference().lineWidth <= 0.0) return;\n    this._updateFilter();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateLineCap();\n    this._updateLineDash();\n    this._updateLineDashOffset();\n    this._updateLineJoin();\n    this._updateLineWidth();\n    this._updateMiterLimit();\n    this._updatePath();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateStrokeStyle();\n    this._updateTransform();\n    super._writeZero(CanvasInstruction.Stroke);\n  }\n  //#endregion STROKE\n\n  //#region STROKERECT\n  /**\n   * The CanvasRenderingContext2D.strokeRect() method of the Canvas 2D API draws a rectangle that is\n   * stroked (outlined) according to the current strokeStyle and other context settings. This method\n   * draws directly to the canvas without modifying the current path, so any subsequent fill() or\n   * stroke() calls will have no effect on it.\n   *\n   * @param {f64} x - The x-axis coordinate of the rectangle's starting point.\n   * @param {f64} y - The y-axis coordinate of the rectangle's starting point.\n   * @param {f64} width - The rectangle's width. Positive values are to the right, and negative to\n   * the left.\n   * @param {f64} height - The rectangle's height. Positive values are down, and negative are up.\n   */\n  public strokeRect(x: f64, y: f64, width: f64, height: f64): void {\n    /**\n     * If the lineWidth is zero, there is no line and it does not matter if ctx.stroke() is called.\n     */\n    if (this._stack.reference().lineWidth <= 0.0) return;\n    this._updateFilter();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateLineCap();\n    this._updateLineDash();\n    this._updateLineDashOffset();\n    this._updateLineJoin();\n    this._updateLineWidth();\n    this._updateMiterLimit();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateStrokeStyle();\n    this._updateTransform();\n    super._writeFour(CanvasInstruction.StrokeRect, x, y, width, height);\n  }\n  //#endregion STROKERECT\n\n  //#region STROKETEXT\n  /**\n   * The CanvasRenderingContext2D method strokeText(), part of the Canvas 2D API, strokes — that is,\n   * draws the outlines of — the characters of a text string at the specified coordinates. An\n   * optional parameter allows specifying a maximum width for the rendered text, which the user\n   * agent will achieve by condensing the text or by using a lower font size. This method draws\n   * directly to the canvas without modifying the current path, so any subsequent fill() or stroke()\n   * calls will have no effect on it. To use the maxWidth parameter, use the strokeTextWidth\n   * function.\n   *\n   * @param {string} text - A DOMString specifying the text string to render into the context. The\n   * text is rendered using the settings specified by font, textAlign, textBaseline, and direction.\n   * @param {f64} x - The x-axis coordinate of the point at which to begin drawing the text.\n   * @param {f64} y - The y-axis coordinate of the point at which to begin drawing the text.\n   */\n  public strokeText(text: string, x: f64, y: f64): void {\n    if (!isFinite(x + y) || text == null || text.length == 0) return;\n    this._updateDirection();\n    this._updateFilter();\n    this._updateFont();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateLineCap();\n    this._updateLineDash();\n    this._updateLineDashOffset();\n    this._updateLineJoin();\n    this._updateLineWidth();\n    this._updateMiterLimit();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateStrokeStyle();\n    this._updateTextAlign();\n    this._updateTextBaseline();\n    this._updateTransform();\n    super._retain(changetype<usize>(text));\n    super._writeThree(CanvasInstruction.StrokeText, <f64>changetype<usize>(text), x, y)\n  }\n\n  /**\n   * The CanvasRenderingContext2D method strokeTextWidth(), part of the Canvas 2D API, strokes —\n   * that is, draws the outlines of — the characters of a text string at the specified coordinates.\n   * An optional parameter allows specifying a maximum width for the rendered text, which the user\n   * agent will achieve by condensing the text or by using a lower font size. This method draws\n   * directly to the canvas without modifying the current path, so any subsequent fill() or stroke()\n   * calls will have no effect on it. To use the maxWidth parameter, use the strokeTextWidth\n   * function.\n   *\n   * @param {string} text - A DOMString specifying the text string to render into the context. The\n   * text is rendered using the settings specified by font, textAlign, textBaseline, and direction.\n   * @param {f64} x - The x-axis coordinate of the point at which to begin drawing the text.\n   * @param {f64} y - The y-axis coordinate of the point at which to begin drawing the text.\n   * @param {f64} maxWidth - The maximum width the text may be once rendered. If not specified,\n   * there is no limit to the width of the text. However, if this value is provided, the user agent\n   * will adjust the kerning, select a more horizontally condensed font (if one is available or can\n   * be generated without loss of quality), or scale down to a smaller font size in order to fit the\n   * text in the specified width.\n   */\n  public strokeTextWidth(text: string, x: f64, y: f64, maxWidth: f64): void {\n    if (!isFinite(x + y + maxWidth) || text == null || text.length == 0 || maxWidth < 0) return;\n    this._updateDirection();\n    this._updateFilter();\n    this._updateFont();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateLineCap();\n    this._updateLineDash();\n    this._updateLineDashOffset();\n    this._updateLineJoin();\n    this._updateLineWidth();\n    this._updateMiterLimit();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateStrokeStyle();\n    this._updateTextAlign();\n    this._updateTextBaseline();\n    this._updateTransform();\n    super._retain(changetype<usize>(text));\n    super._writeFour(CanvasInstruction.StrokeTextWidth, <f64>changetype<usize>(text), x, y, maxWidth);\n  }\n  //#endregion STROKETEXT\n\n  //#region TRANSFORM\n  /**\n   * The CanvasRenderingContext2D.transform() method of the Canvas 2D API multiplies the current\n   * transformation with the matrix described by the arguments of this method. This lets you scale,\n   * rotate, translate (move), and skew the context.\n   *\n   * @param {f64} a - Horizontal scaling. A value of 1 results in no scaling.\n   * @param {f64} b - Vertical skewing.\n   * @param {f64} c - Horizontal skewing.\n   * @param {f64} d - Vertical scaling. A value of 1 results in no scaling.\n   * @param {f64} e - Horizontal translation (moving).\n   * @param {f64} f - Vertical translation (moving).\n   */\n  public transform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\n    if (!isFinite(a + b + c + d + e + f)) return;\n    if (ASC_FEATURE_SIMD) {\n      let stack = this._stack.dereference();\n      let ab = v128.load(stack, offsetof<CanvasStack>(\"a\"));\n      let cd = v128.load(stack, offsetof<CanvasStack>(\"c\"));\n      let ef = v128.load(stack, offsetof<CanvasStack>(\"e\"));\n      v128.store(\n        stack,\n        v128.add<f64>(\n          v128.mul<f64>(ab, v128.splat<f64>(a)),\n          v128.mul<f64>(cd, v128.splat<f64>(b)),\n        ),\n        offsetof<CanvasStack>(\"a\"),\n      );\n      v128.store(\n        stack,\n        v128.add<f64>(\n          v128.mul<f64>(ab, v128.splat<f64>(c)),\n          v128.mul<f64>(cd, v128.splat<f64>(d)),\n        ),\n        offsetof<CanvasStack>(\"c\"),\n      );\n      v128.store(\n        stack,\n        v128.add<f64>(\n          v128.add<f64>(\n            v128.mul<f64>(ab, v128.splat<f64>(e)),\n            v128.mul<f64>(cd, v128.splat<f64>(f)),\n          ),\n          ef,\n        ),\n        offsetof<CanvasStack>(\"e\"),\n      );\n    } else {\n      let stack = this._stack.reference();\n      var sa = stack.a;\n      var sb = stack.b;\n      var sc = stack.c;\n      var sd = stack.d;\n      var se = stack.e;\n      var sf = stack.f;\n      stack.a = sa * a + sc * b;\n      stack.b = sb * a + sd * b;\n      stack.c = sa * c + sc * d;\n      stack.d = sb * c + sd * d;\n      stack.e = sa * e + sc * f + se;\n      stack.f = sb * e + sd * f + sf;\n    }\n  }\n  //#endregion TRANSFORM\n\n  //#region TRANSLATE\n  /**\n   * The CanvasRenderingContext2D.translate() method of the Canvas 2D API adds a translation\n   * transformation to the current matrix.\n   * @param {f64} x - Distance to move in the horizontal direction. Positive values are to the\n   * right, and negative to the left.\n   * @param {f64} y - Distance to move in the vertical direction. Positive values are down, and\n   * negative are up.\n   */\n  public translate(x: f64, y: f64): void {\n    if (!isFinite(x + y)) return;\n\n    if (ASC_FEATURE_SIMD) {\n      let stack = this._stack.dereference();\n      v128.store(\n        stack,\n        v128.add<f64>(\n          v128.mul<f64>(\n            v128.load(stack, offsetof<CanvasStack>(\"a\")),\n            v128.splat<f64>(x),\n          ),\n          v128.mul<f64>(\n            v128.load(stack, offsetof<CanvasStack>(\"c\")),\n            v128.splat<f64>(y),\n          ),\n        ),\n        offsetof<CanvasStack>(\"e\"),\n      );\n    } else {\n      let stack = this._stack.reference();\n      stack.e += stack.a * x + stack.c * y;\n      stack.f += stack.b * x + stack.d * y;\n    }\n  }\n  //#endregion TRANSLATE\n\n  public commit(): void {\n    super._writeZero(CanvasInstruction.Commit);\n    render(this.id, changetype<usize>(this._buffer));\n    super._resetBuffer();\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK, BLOCK_MAXSIZE, BLOCK_OVERHEAD } from \"./rt/common\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  get length(): i32 {\n    ERROR(\"missing implementation: subclasses must implement ArrayBufferView#length\");\n    return unreachable();\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = __alloc(length = length << alignLog2, idof<ArrayBuffer>());\n    memory.fill(buffer, 0, <usize>length);\n    this.buffer = changetype<ArrayBuffer>(buffer); // retains\n    this.dataStart = buffer;\n    this.byteLength = length;\n  }\n}\n\n@sealed export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (value === null) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = __alloc(<usize>length, idof<ArrayBuffer>());\n    memory.fill(buffer, 0, <usize>length);\n    return changetype<ArrayBuffer>(buffer); // retains\n  }\n\n  get byteLength(): i32 {\n    return changetype<BLOCK>(changetype<usize>(this) - BLOCK_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    var length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    var outSize = <usize>max(end - begin, 0);\n    var out = __alloc(outSize, idof<ArrayBuffer>());\n    memory.copy(out, changetype<usize>(this) + <usize>begin, outSize);\n    return changetype<ArrayBuffer>(out); // retains\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\nimport { ArrayBufferView } from \"../arraybuffer\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline\nconst POWERS10: u32[] = [\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n];\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline\nconst DIGITS: u32[] = [\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n];\n\n// @ts-ignore: decorator\n@lazy @inline\nconst EXP_POWERS: i16[] = [\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n];\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline\nconst FRC_POWERS: u64[] = [\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n];\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return select<u32>(1, 2, value < 10);\n    } else {\n      let m = select<u32>(4, 5, value < 10000);\n      return select<u32>(3, m, value < 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return select<u32>(6, 7, value < 1000000);\n    } else {\n      let m = select<u32>(9, 10, value < 1000000000);\n      return select<u32>(8, m, value < 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      let m = select<u32>(11, 12, value < 100000000000);\n      return select<u32>(10, m, value < 10000000000);\n    } else {\n      let m = select<u32>(14, 15, value < 100000000000000);\n      return select<u32>(13, m, value < 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return select<u32>(16, 17, value < 10000000000000000);\n    } else {\n      let m = select<u32>(19, 20, value < 10000000000000000000);\n      return select<u32>(18, m, value < 1000000000000000000);\n    }\n  }\n}\n\nfunction utoa32_lut(buffer: usize, num: u32, offset: usize): void {\n  var lut = changetype<ArrayBufferView>(DIGITS).dataStart;\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(lut + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(lut + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(lut + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(lut + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_lut(buffer: usize, num: u64, offset: usize): void {\n  var lut = changetype<ArrayBufferView>(DIGITS).dataStart;\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(lut + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(lut + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(lut + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(lut + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset -= 1;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_core(buffer: usize, num: u32, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, offset);\n  } else {\n    utoa32_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa64_core(buffer: usize, num: u64, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, offset);\n  } else {\n    utoa64_lut(buffer, num, offset);\n  }\n}\n\nexport function utoa32(value: u32): String {\n  if (!value) return \"0\";\n\n  var decimals = decimalCount32(value);\n  var out = __alloc(decimals << 1, idof<String>());\n\n  utoa32_core(out, value, decimals);\n  return changetype<String>(out); // retains\n}\n\nexport function itoa32(value: i32): String {\n  if (!value) return \"0\";\n\n  var sign = value < 0;\n  if (sign) value = -value;\n\n  var decimals = decimalCount32(value) + u32(sign);\n  var out = __alloc(decimals << 1, idof<String>());\n\n  utoa32_core(out, value, decimals);\n  if (sign) store<u16>(out, CharCode.MINUS);\n  return changetype<String>(out); // retains\n}\n\nexport function utoa64(value: u64): String {\n  if (!value) return \"0\";\n\n  var out: usize;\n  if (value <= u32.MAX_VALUE) {\n    let val32    = <u32>value;\n    let decimals = decimalCount32(val32);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa32_core(out, val32, decimals);\n  } else {\n    let decimals = decimalCount64(value);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_core(out, value, decimals);\n  }\n  return changetype<String>(out); // retains\n}\n\nexport function itoa64(value: i64): String {\n  if (!value) return \"0\";\n\n  var sign = value < 0;\n  if (sign) value = -value;\n\n  var out: usize;\n  if (<u64>value <= <u64>u32.MAX_VALUE) {\n    let val32    = <u32>value;\n    let decimals = decimalCount32(val32) + u32(sign);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa32_core(out, val32, decimals);\n  } else {\n    let decimals = decimalCount64(value) + u32(sign);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_core(out, value, decimals);\n  }\n  if (sign) store<u16>(out, CharCode.MINUS);\n\n  return changetype<String>(out); // retains\n}\n\nexport function itoa<T extends number>(value: T): String {\n  if (!isInteger<T>()) ERROR(\"integer type expected\");\n  if (isSigned<T>()) {\n    if (sizeof<T>() <= 4) {\n      return itoa32(<i32>value);\n    } else {\n      return itoa64(<i64>value);\n    }\n  } else {\n    if (sizeof<T>() <= 4) {\n      return utoa32(<u32>value);\n    } else {\n      return utoa64(<u64>value);\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy\nvar _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// var _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  var u0 = u & 0xFFFFFFFF;\n  var v0 = v & 0xFFFFFFFF;\n\n  var u1 = u >> 32;\n  var v1 = v >> 32;\n\n  var l = u0 * v0;\n  var t = u1 * v0 + (l >> 32);\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  var frc = (f << 1) + 1;\n  var exp = e - 1;\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  var lastp = buffer + ((len - 1) << 1);\n  var digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  var k = <i32>dk;\n      k += i32(k != dk); // conversion with ceil\n\n  var index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = unchecked(FRC_POWERS[index]);\n  _exp_pow = unchecked(<i32>EXP_POWERS[index]);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  var uv  = reinterpret<u64>(value);\n  var exp = <i32>((uv & 0x7FF0000000000000) >>> 52);\n  var sid = uv & 0x000FFFFFFFFFFFFF;\n  var frc = (u64(exp != 0) << 52) + sid;\n      exp = select<i32>(exp, 1, exp != 0) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var frc_pow = _frc_pow;\n  var exp_pow = _exp_pow;\n\n  var w_frc = umul64f(frc, frc_pow);\n  var w_exp = umul64e(exp, exp_pow);\n\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  var wp_exp = umul64e(_exp,      exp_pow);\n\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  var delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  var one_exp = -mp_exp;\n  var one_frc = (<u64>1) << one_exp;\n  var mask    = one_frc - 1;\n\n  var wp_w_frc = mp_frc - w_frc;\n  var wp_w_exp = mp_exp;\n\n  var p1 = <u32>(mp_frc >> one_exp);\n  var p2 = mp_frc & mask;\n\n  var kappa = <i32>decimalCount32(p1);\n  var len = sign;\n\n  var lut = changetype<ArrayBufferView>(POWERS10).dataStart;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(lut + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (1) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(lut + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n\n  return len;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  var sign = k < 0;\n  if (sign) k = -k;\n  var decimals = decimalCount32(k) + 1;\n  utoa32_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  var kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nexport function dtoa_core(buffer: usize, value: f64): i32 {\n  var sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  var len = grisu2(value, buffer, sign);\n      len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite<f64>(value)) {\n    if (isNaN<f64>(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  var buffer = __alloc(MAX_DOUBLE_LENGTH << 1, idof<String>());\n  var length = dtoa_core(buffer, value);\n  if (length == MAX_DOUBLE_LENGTH) return changetype<String>(buffer);\n  var result = changetype<String>(buffer).substring(0, length);\n  __free(buffer);\n  return result;\n}\n\nexport function itoa_stream<T extends number>(buffer: usize, offset: usize, value: T): u32 {\n  buffer += (offset << 1);\n  if (!value) {\n    store<u16>(buffer, CharCode._0);\n    return 1;\n  }\n  var decimals: u32 = 0;\n  if (isSigned<T>()) {\n    let sign = i32(value < 0);\n    if (sign) value = changetype<T>(-value);\n    if (sizeof<T>() <= 4) {\n      decimals = decimalCount32(value) + <u32>sign;\n      utoa32_core(buffer, value, decimals);\n    } else {\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\n        let val32 = <u32>value;\n        decimals = decimalCount32(val32) + <u32>sign;\n        utoa32_core(buffer, val32, decimals);\n      } else {\n        decimals = decimalCount64(value) + <u32>sign;\n        utoa64_core(buffer, value, decimals);\n      }\n    }\n    if (sign) store<u16>(buffer, CharCode.MINUS);\n  } else {\n    if (sizeof<T>() <= 4) {\n      decimals = decimalCount32(value);\n      utoa32_core(buffer, value, decimals);\n    } else {\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\n        let val32 = <u32>value;\n        decimals = decimalCount32(val32);\n        utoa32_core(buffer, val32, decimals);\n      } else {\n        decimals = decimalCount64(value);\n        utoa64_core(buffer, value, decimals);\n      }\n    }\n  }\n  return decimals;\n}\n\nexport function dtoa_stream(buffer: usize, offset: usize, value: f64): u32 {\n  buffer += (offset << 1);\n  if (value == 0.0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite<f64>(value)) {\n    if (isNaN<f64>(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = i32(value < 0);\n      let len  = 8 + sign;\n      memory.copy(buffer, changetype<usize>(select<String>(\"-Infinity\", \"Infinity\", sign)), len << 1);\n      return len;\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","import { itoa, dtoa, itoa_stream, dtoa_stream, MAX_DOUBLE_LENGTH } from \"./number\";\nimport { ipow32 } from \"../math\";\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\n// 9 * 8 = 72 bytes\n// @ts-ignore: decorator\n@lazy\nconst Powers10Hi: f64[] = [1, 1e32, 1e64, 1e96, 1e128, 1e160, 1e192, 1e224, 1e256, 1e288];\n// 32 * 8 = 256 bytes\n// @ts-ignore: decorator\n@lazy\nconst Powers10Lo: f64[] = [\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22, 1e23, 1e24, 1e25, 1e26, 1e27, 1e28, 1e29,\n  1e30, 1e31\n];\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  var ptr1 = changetype<usize>(str1) + (index1 << 1);\n  var ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\nexport function isSpace(c: i32): bool {\n  if (c <= 0xFF) {\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    return c == 0x20 || <u32>(c - 0x09) <= 0x0D - 0x09 || c == 0xA0;\n  }\n  if (<u32>(c - 0x2000) <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  var len = str.length;\n  if (!len) {\n    // @ts-ignore: cast\n    if (isFloat<T>()) return <T>NaN;\n    // @ts-ignore: cast\n    return <T>0;\n  }\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <u32>load<u16>(ptr);\n\n  // determine sign\n  // @ts-ignore: cast\n  var sign: T = 1;\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (code == CharCode.MINUS) {\n    if (!--len) {\n      // @ts-ignore: cast\n      if (isFloat<T>()) return <T>NaN;\n      // @ts-ignore: cast\n      return <T>0;\n    }\n    code = <u32>load<u16>(ptr += 2);\n    // @ts-ignore: type\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) {\n      // @ts-ignore: cast\n      if (isFloat<T>()) return <T>NaN;\n      // @ts-ignore: cast\n      return <T>0;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // determine radix\n  if (!radix) {\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr + 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n        default: radix = 10;\n      }\n    } else radix = 10;\n  } else if (radix < 2 || radix > 36) {\n    // @ts-ignore: cast\n    if (isFloat<T>()) return <T>NaN;\n    // @ts-ignore: cast\n    return <T>0;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  var num: T = 0;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    } else break;\n    if (code >= <u32>radix) break;\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  var len = str.length;\n  if (!len) return NaN;\n\n  var ptr  = changetype<usize>(str);\n  var code = <u32>load<u16>(ptr);\n\n  var sign = 1.;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return copysign<f64>(Infinity, sign);\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  var savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0;\n  const capacity = 19; // int(64 * 0.3010)\n  var pointed = false;\n  var consumed = 0;\n  var position = 0;\n  var x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  var sepLen = separator.length;\n  var valueLen = 5; // max possible length of element len(\"false\")\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n  var offset = 0;\n  var value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  // @ts-ignore: type\n  if (!lastIndex) return changetype<string>(itoa<T>(load<T>(dataStart))); // retains\n\n  var sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    ); // retains\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  var sepLen = separator.length;\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    offset += dtoa_stream(changetype<usize>(result), offset,\n      // @ts-ignore: type\n      value\n    );\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  offset += dtoa_stream(changetype<usize>(result), offset,\n    // @ts-ignore: type\n    value\n  );\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  var estLen = 0;\n  var value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    // @ts-ignore: type\n    if (value !== null) estLen += value.length;\n  }\n  var offset = 0;\n  var sepLen = separator.length;\n  var result = __alloc((estLen + sepLen * lastIndex) << 1, idof<string>());\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (value !== null) {\n      let valueLen = value.length;\n      memory.copy(\n        result + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        result + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (value !== null) {\n    memory.copy(\n      result + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return changetype<string>(result); // retains\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  var value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value !== null ? value.toString() : \"\";\n  }\n  var result = \"\";\n  var sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value !== null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value !== null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  var significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  var shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  var b = <u64>ipow32(5, -exp);\n  var q = significand / b;\n  var r = significand % b;\n  var s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  var shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  var sign = 1, magnitude = 0;\n  var code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy\nvar __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  var low  = (a & 0xFFFFFFFF) * b;\n  var high = (a >> 32) * b + (low >> 32);\n  var overflow = <u32>(high >> 32);\n  var space = clz(overflow);\n  var revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\nfunction pow10(n: i32): f64 {\n  // @ts-ignore: type\n  const hi = Powers10Hi.dataStart;\n  // @ts-ignore: type\n  const lo = Powers10Lo.dataStart;\n  return (\n    load<f64>(hi + ((n >> 5) << alignof<f64>())) *\n    load<f64>(lo + ((n & 31) << alignof<f64>()))\n  );\n}\n","import { COMPARATOR, SORT as SORT_IMPL } from \"./util/sort\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH } from \"./util/error\";\nimport { joinIntegerArray, joinFloatArray } from \"./util/string\";\nimport { idof } from \"./builtins\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\nexport class Int8Array extends ArrayBufferView {\n  [key: number]: i8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i8>();\n\n  constructor(length: i32) {\n    super(length, alignof<i8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i8 {\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i8>): void {\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return FILL<Int8Array, i8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    return SORT<Int8Array, i8>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SLICE<Int8Array, i8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {\n    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, fn);\n  }\n\n  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {\n    return FILTER<Int8Array, i8>(this, fn);\n  }\n\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, fn);\n  }\n\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, fn);\n  }\n\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i8>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i8>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8Array extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return FILL<Uint8Array, u8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    return SORT<Uint8Array, u8>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SLICE<Uint8Array, u8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {\n    return FILTER<Uint8Array, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u8>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8ClampedArray extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return FILL<Uint8ClampedArray, u8>(this, value, start, end);\n  }\n\n  sort(fn: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    return SORT<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SLICE<Uint8ClampedArray, u8>(this, begin, end);\n  }\n\n  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {\n    return FILTER<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u8>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int16Array extends ArrayBufferView {\n  [key: number]: i16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i16>();\n\n  constructor(length: i32) {\n    super(length, alignof<i16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i16 {\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i16>): void {\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return FILL<Int16Array, i16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    return SORT<Int16Array, i16>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SLICE<Int16Array, i16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {\n    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, fn);\n  }\n\n  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {\n    return FILTER<Int16Array, i16>(this, fn);\n  }\n\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, fn);\n  }\n\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, fn);\n  }\n\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i16>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i16>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint16Array extends ArrayBufferView {\n  [key: number]: u16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u16>();\n\n  constructor(length: i32) {\n    super(length, alignof<u16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u16 {\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u16>): void {\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return FILL<Uint16Array, u16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    return SORT<Uint16Array, u16>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SLICE<Uint16Array, u16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, fn);\n  }\n\n  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {\n    return FILTER<Uint16Array, u16>(this, fn);\n  }\n\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, fn);\n  }\n\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, fn);\n  }\n\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u16>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u16>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int32Array extends ArrayBufferView {\n  [key: number]: i32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i32>();\n\n  constructor(length: i32) {\n    super(length, alignof<i32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i32 {\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i32): void {\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return FILL<Int32Array, i32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    return SORT<Int32Array, i32>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SLICE<Int32Array, i32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {\n    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, fn);\n  }\n\n  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {\n    return FILTER<Int32Array, i32>(this, fn);\n  }\n\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, fn);\n  }\n\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, fn);\n  }\n\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i32>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i32>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint32Array extends ArrayBufferView {\n  [key: number]: u32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u32>();\n\n  constructor(length: i32) {\n    super(length, alignof<u32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u32 {\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u32): void {\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return FILL<Uint32Array, u32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    return SORT<Uint32Array, u32>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SLICE<Uint32Array, u32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, fn);\n  }\n\n  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {\n    return FILTER<Uint32Array, u32>(this, fn);\n  }\n\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, fn);\n  }\n\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, fn);\n  }\n\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u32>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u32>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int64Array extends ArrayBufferView {\n  [key: number]: i64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i64>();\n\n  constructor(length: i32) {\n    super(length, alignof<i64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i64 {\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i64): void {\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return FILL<Int64Array, i64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    return SORT<Int64Array, i64>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SLICE<Int64Array, i64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {\n    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, fn);\n  }\n\n  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {\n    return FILTER<Int64Array, i64>(this, fn);\n  }\n\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, fn);\n  }\n\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, fn);\n  }\n\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i64>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i64>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint64Array extends ArrayBufferView {\n  [key: number]: u64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u64>();\n\n  constructor(length: i32) {\n    super(length, alignof<u64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u64 {\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u64): void {\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return FILL<Uint64Array, u64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    return SORT<Uint64Array, u64>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SLICE<Uint64Array, u64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, fn);\n  }\n\n  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {\n    return FILTER<Uint64Array, u64>(this, fn);\n  }\n\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, fn);\n  }\n\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, fn);\n  }\n\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u64>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u64>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float32Array extends ArrayBufferView {\n  [key: number]: f32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<f32>();\n\n  constructor(length: i32) {\n    super(length, alignof<f32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f32 {\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f32): void {\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return FILL<Float32Array, f32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    return SORT<Float32Array, f32>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SLICE<Float32Array, f32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {\n    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, fn);\n  }\n\n  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {\n    return FILTER<Float32Array, f32>(this, fn);\n  }\n\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, fn);\n  }\n\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, fn);\n  }\n\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, f32>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f32>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float64Array extends ArrayBufferView {\n  [key: number]: f64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<f64>();\n\n  constructor(length: i32) {\n    super(length, alignof<f64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f64 {\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f64): void {\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return FILL<Float64Array, f64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    return SORT<Float64Array, f64>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SLICE<Float64Array, f64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {\n    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, fn);\n  }\n\n  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {\n    return FILTER<Float64Array, f64>(this, fn);\n  }\n\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, fn);\n  }\n\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, fn);\n  }\n\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, f64>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f64>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILL<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  value: native<T>,\n  start: i32,\n  end: i32\n): TArray {\n  var dataStart = array.dataStart;\n  var len = array.length;\n  start = start < 0 ? max(len + start, 0) : min(start, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  if (sizeof<T>() == 1) {\n    if (start < end) memory.fill(dataStart + <usize>start, <u8>value, <usize>(end - start));\n  } else {\n    for (; start < end; ++start) {\n      store<T>(dataStart + (<usize>start << alignof<T>()), value);\n    }\n  }\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SORT<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  comparator: (a: T, b: T) => i32\n): TArray {\n  var len = array.length;\n  if (len <= 1) return array;\n  var base = array.dataStart;\n  if (len == 2) {\n    let a: T = load<T>(base, sizeof<T>()); // a = arr[1]\n    let b: T = load<T>(base); // b = arr[0]\n    if (comparator(a, b) < 0) {\n      store<T>(base, b, sizeof<T>()); // arr[1] = b\n      store<T>(base, a); // arr[0] = a\n    }\n    return array;\n  }\n  SORT_IMPL<T>(base, len, comparator);\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SLICE<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  start: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  start  = start < 0 ? max(start + len, 0) : min(start, len);\n  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);\n  len = max(end - start, 0);\n  var slice = instantiate<TArray>(len);\n  memory.copy(\n    slice.dataStart,\n    array.dataStart + (<usize>start << alignof<T>()),\n    <usize>len << alignof<T>()\n  );\n  return slice;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SUBARRAY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  end   = max(end, begin);\n\n  var out = __alloc(offsetof<TArray>(), idof<TArray>());\n  store<usize>(out, __retain(changetype<usize>(array.buffer)), offsetof<TArray>(\"buffer\"));\n  store<usize>(out, array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>(\"dataStart\"));\n  store<u32>(out, (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return changetype<TArray>(out); // retains\n}\n\n// @ts-ignore: decorator\n@inline\nfunction COPY_WITHIN<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  target: i32,\n  start: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  var dataStart = array.dataStart;\n\n      end   = min<i32>(end, len);\n  var to    = target < 0 ? max(len + target, 0) : min(target, len);\n  var from  = start < 0 ? max(len + start, 0) : min(start, len);\n  var last  = end < 0 ? max(len + end, 0) : min(end, len);\n  var count = min(last - from, len - to);\n\n  memory.copy(\n    dataStart + (<usize>to << alignof<T>()),\n    dataStart + (<usize>from << alignof<T>()),\n    <usize>count << alignof<T>()\n  );\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    initialValue = fn(initialValue, load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var dataStart = array.dataStart;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = fn(initialValue, load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction MAP<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  var len = array.length;\n  var dataStart = array.dataStart;\n\n  var byteLength = len << alignof<T>();\n  var out = __alloc(offsetof<TArray>(), idof<TArray>());\n  var buffer = __alloc(byteLength, idof<ArrayBuffer>());\n  for (let i = 0; i < len; i++) {\n    store<T>(\n      buffer + (<usize>i << alignof<T>()),\n      fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)\n    );\n  }\n  store<usize>(out, __retain(buffer), offsetof<TArray>(\"buffer\"));\n  store<usize>(out, buffer, offsetof<TArray>(\"dataStart\"));\n  store<u32>(out, byteLength, offsetof<TArray>(\"byteLength\"));\n  return changetype<TArray>(out); // retains\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILTER<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => bool,\n): TArray {\n  var len = array.length;\n  var out = __alloc(offsetof<TArray>(), idof<TArray>());\n  var buffer = __alloc(len << alignof<T>(), idof<ArrayBuffer>());\n  var dataStart  = array.dataStart;\n  var j: usize = 0;\n  for (let i = 0; i < len; i++) {\n    let value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    if (fn(value, i, array)) {\n      store<T>(\n        buffer + (j++ << alignof<T>()),\n        value\n      );\n    }\n  }\n  // shrink output buffer\n  var byteLength = j << alignof<T>();\n  var data = __realloc(buffer, byteLength);\n  store<usize>(out, __retain(data), offsetof<TArray>(\"buffer\"));\n  store<u32>(out, byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(out, data, offsetof<TArray>(\"dataStart\"));\n  return changetype<TArray>(out); // retains\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_INDEX<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INCLUDES<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): bool {\n  if (isFloat<T>()) {\n    let index: isize = fromIndex;\n    let length: isize = array.length;\n    if (length == 0 || index >= length) return false;\n    if (index < 0) index = max(length + index, 0);\n    let dataStart = array.dataStart;\n    while (index < length) {\n      let elem = load<T>(dataStart + (index << alignof<T>()));\n      // @ts-ignore\n      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;\n      ++index;\n    }\n    return false;\n  } else {\n    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var length: isize = array.length;\n  if (length == 0 || index >= length) return -1;\n  if (index < 0) index = max(length + index, 0);\n  var dataStart = array.dataStart;\n  while (index < length) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    ++index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var length: isize = array.length;\n  if (length == 0) return -1;\n  if (index < 0) index = length + index; // no need to clamp\n  else if (index >= length) index = length - 1;\n  var dataStart = array.dataStart;\n  while (index >= 0) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    --index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SOME<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) return true;\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction EVERY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) continue;\n    return false;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FOREACH<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => void,\n): void {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REVERSE<TArray extends ArrayBufferView, T>(array: TArray): TArray {\n  var dataStart = array.dataStart;\n  for (let front: usize = 0, back: usize = array.length - 1; front < back; ++front, --back) {\n    let frontPtr = dataStart + (front << alignof<T>());\n    let backPtr = dataStart + (back << alignof<T>());\n    let temp = load<T>(frontPtr);\n    store<T>(frontPtr, load<T>(backPtr));\n    store<T>(backPtr, temp);\n  }\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction WRAP<TArray extends ArrayBufferView, T>(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): TArray {\n  var bufferByteLength = buffer.byteLength;\n  if (<u32>byteOffset >= <u32>bufferByteLength) {\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  var byteLength: i32;\n  if (length < 0) {\n    if (length == -1) {\n      const mask = <i32>(1 << alignof<T>() - 1);\n      if (buffer.byteLength & mask) {\n        throw new RangeError(E_INVALIDLENGTH);\n      } else {\n        byteLength = buffer.byteLength;\n      }\n    } else {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  } else {\n    byteLength = length << alignof<T>();\n  }\n  if (byteOffset + byteLength > buffer.byteLength) {\n    throw new RangeError(E_INVALIDLENGTH);\n  }\n  var out = __alloc(offsetof<TArray>(), idof<TArray>());\n  store<usize>(out, __retain(changetype<usize>(buffer)), offsetof<TArray>(\"buffer\"));\n  store<u32>(out, byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(out, changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>(\"dataStart\"));\n  return changetype<TArray>(out); // retains\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\nimport { E_KEYNOTFOUND } from \"util/error\";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline\nconst INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline\nconst FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline\nconst FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline\nconst FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline\nconst FREE_FACTOR_D = 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline\nconst EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline\nconst BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets holding references to the respective first entry within\n  private buckets: ArrayBuffer; // usize[bucketsMask + 1]\n  private bucketsMask: u32;\n\n  // entries in insertion order\n  private entries: ArrayBuffer; // MapEntry<K,V>[entriesCapacity]\n  private entriesCapacity: i32;\n  private entriesOffset: i32;\n  private entriesCount: i32;\n\n  get size(): i32 { return this.entriesCount; }\n\n  constructor() {\n    this.clear();\n  }\n\n  clear(): void {\n    const bucketsSize = INITIAL_CAPACITY * <i32>BUCKET_SIZE;\n    this.buckets = new ArrayBuffer(bucketsSize);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    const entriesSize = INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>();\n    this.entries = new ArrayBuffer(entriesSize);\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    var entry = load<MapEntry<K,V>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      if (!(entry.taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(entry.taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH<K>(key)) !== null;\n  }\n\n  @operator(\"[]\")\n  get(key: K): V {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`\n    return entry.value;\n  }\n\n  @operator(\"[]=\")\n  set(key: K, value: V): void {\n    var hashCode = HASH<K>(key);\n    var entry = this.find(key, hashCode); // unmanaged!\n    if (entry) {\n      if (isManaged<V>()) {\n        let oldRef = changetype<usize>(entry.value);\n        if (changetype<usize>(value) != oldRef) {\n          entry.value = changetype<V>(__retain(changetype<usize>(value)));\n          __release(oldRef);\n        }\n      } else {\n        entry.value = value;\n      }\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + this.entriesOffset++ * ENTRY_SIZE<K,V>());\n      // link with the map\n      entry.key = isManaged<K>()\n        ? changetype<K>(__retain(changetype<usize>(key)))\n        : key;\n      entry.value = isManaged<V>()\n        ? changetype<V>(__retain(changetype<usize>(value)))\n        : value;\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n  }\n\n  delete(key: K): bool {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    if (isManaged<K>()) __release(changetype<usize>(entry.key));\n    if (isManaged<V>()) __release(changetype<usize>(entry.value));\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    var halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    var newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());\n\n    // copy old entries to new entries\n    var oldPtr = changetype<usize>(this.entries);\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    var newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        newEntry.key = oldEntry.key;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = HASH<K>(oldEntry.key) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  keys(): K[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var keys = new Array<K>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        keys.push(entry.key);\n        ++length;\n      }\n    }\n    keys.length = length;\n    return keys;\n  }\n\n  values(): V[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var values = new Array<V>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        values.push(entry.value);\n        ++length;\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Map]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit_impl(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    var entries = changetype<usize>(this.entries);\n    if (isManaged<K>() || isManaged<V>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n      while (cur < end) {\n        let entry = changetype<MapEntry<K,V>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          if (isManaged<K>()) {\n            let val = changetype<usize>(entry.key);\n            if (isNullable<K>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n          if (isManaged<V>()) {\n            let val = changetype<usize>(entry.value);\n            if (isNullable<V>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n        }\n        cur += ENTRY_SIZE<K,V>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","// @ts-ignore: decorator\n@inline\nexport function HASH<T>(key: T): u32 {\n  if (isString<T>()) {\n    return hashStr(changetype<string>(key));\n  } else if (isReference<T>()) {\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));\n  } else {\n    if (sizeof<T>() == 1) return hash8 (u32(key));\n    if (sizeof<T>() == 2) return hash16(u32(key));\n    if (sizeof<T>() == 4) return hash32(u32(key));\n    if (sizeof<T>() == 8) return hash64(u64(key));\n  }\n  return unreachable();\n}\n\n// FNV-1a 32-bit as a starting point, see: http://isthe.com/chongo/tech/comp/fnv/\n\n// @ts-ignore: decorator\n@inline\nconst FNV_OFFSET: u32 = 2166136261;\n\n// @ts-ignore: decorator\n@inline\nconst FNV_PRIME: u32 = 16777619;\n\nfunction hash8(key: u32): u32 {\n  return (FNV_OFFSET ^ key) * FNV_PRIME;\n}\n\nfunction hash16(key: u32): u32 {\n  var v = FNV_OFFSET;\n  v = (v ^ ( key        & 0xff)) * FNV_PRIME;\n  v = (v ^ ( key >>  8        )) * FNV_PRIME;\n  return v;\n}\n\nfunction hash32(key: u32): u32 {\n  var v = FNV_OFFSET;\n  v = (v ^ ( key        & 0xff)) * FNV_PRIME;\n  v = (v ^ ((key >>  8) & 0xff)) * FNV_PRIME;\n  v = (v ^ ((key >> 16) & 0xff)) * FNV_PRIME;\n  v = (v ^ ( key >> 24        )) * FNV_PRIME;\n  return v;\n}\n\nfunction hash64(key: u64): u32 {\n  var l = <u32> key;\n  var h = <u32>(key >>> 32);\n  var v = FNV_OFFSET;\n  v = (v ^ ( l        & 0xff)) * FNV_PRIME;\n  v = (v ^ ((l >>  8) & 0xff)) * FNV_PRIME;\n  v = (v ^ ((l >> 16) & 0xff)) * FNV_PRIME;\n  v = (v ^ ( l >> 24        )) * FNV_PRIME;\n  v = (v ^ ( h        & 0xff)) * FNV_PRIME;\n  v = (v ^ ((h >>  8) & 0xff)) * FNV_PRIME;\n  v = (v ^ ((h >> 16) & 0xff)) * FNV_PRIME;\n  v = (v ^ ( h >> 24        )) * FNV_PRIME;\n  return v;\n}\n\nfunction hashStr(key: string): u32 {\n  var v = FNV_OFFSET;\n  if (key !== null) {\n    for (let i: usize = 0, k: usize = key.length << 1; i < k; ++i) {\n      v = (v ^ <u32>load<u8>(changetype<usize>(key) + i)) * FNV_PRIME;\n    }\n  }\n  return v;\n}\n","import { CanvasRenderingContext2D } from \"../renderer/CanvasRenderingContext2D\";\n\nlet map = new Map<string, CanvasRenderingContext2D>();\n\n/**\n * This internal function is exported via the `./assembly/glue.ts` file. It receives an id from the\n * host, and a name. It's responsible for creating a new CanvasRenderingContext2D object, then\n * stores it on the map object by it's name. This allows developers to call `getContextById(name)`\n * to obtain the created reference to the canvas context.\n *\n * @param {string} name - The name of the CanvasRenderingContext2D object\n * @param {i32} id - The unique objectid created by the browser that identifies the context.\n */\nexport function __use_context(name: string, id: i32): void {\n  var result = new CanvasRenderingContext2D();\n  store<i32>(changetype<usize>(result) + offsetof<CanvasRenderingContext2D>(\"id\"), id);\n  map.set(name, result);\n}\n\n/**\n * This function is the only way to obtain a named canvas provided by the JavaScript host.\n *\n * @param {string} name - This is the name of the provided context.\n */\nexport function getContextById(name: string): CanvasRenderingContext2D {\n  if (!map.has(name)) throw new Error(\"Cannot find context with name: \" + name);\n  return map.get(name);\n}\n","import { STORE } from \"./util\";\n/**\n * The Buffer class is an ArrayBuffer backed data writer that utilizes the internal STORE function\n * provided by AssemblyScript to write data as fast as possible to memory. The generic type\n * parameter represents an enum indicating the instruction type values coupled with the memory\n * writes. Each instruction write results in the following values written to the buffer:\n *\n * 1. [instruction] `T` - This value is the instruction type cast to a `f64`\n * 2. [nextIndex] `i32` - This value is the pointer to the next instruction index\n * 3. [...args] `f64[]` - These values are the argument values for the instruction\n */\nexport class Buffer<T extends i32> {\n  /**\n   * The buffer property is a reference to an allocated block of memory that contains all the\n   * currently written values to the buffer. The browser eventually should obtain a pointer to this\n   * block and read the values from it to perform actions.\n   */\n  protected _buffer: ArrayBuffer = new ArrayBuffer(0x10000 * sizeof<f64>());\n\n  /**\n   * The set of retained pointers that need to be cleaned up after a commit().\n   */\n  protected _retained: ArrayBuffer = new ArrayBuffer(0x10000 << alignof<usize>());\n\n  /**\n   * The offset into the _retained pointer list.\n   */\n  protected _retainedOffset: i32 = 0;\n\n  /**\n   * The offset property is a pointer to the next index that will receive a written value.\n   */\n  private _offset: i32 = 0;\n\n  /**\n   * Write a single instruction to the buffer without any parameters. This results in two values\n   * written to the buffer.\n   *\n   * @param {T} inst - The instruction type to be written to the buffer.\n   */\n  @inline\n  protected _writeZero(inst: T): void {\n    var buff = changetype<usize>(this._buffer);\n    var index: i32 = this._offset;\n    var next: i32 = index + 2;\n    STORE<f64>(buff, index, <f64>inst);\n    STORE<f64>(buff, index + 1, <f64>next);\n    this._offset = next;\n  }\n\n  /**\n   * Write a single instruction to the buffer with a single parameter. This results in three values\n   * written to the buffer.\n   *\n   * @param {T} inst - The instruction type to be written to the buffer.\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\n   */\n  @inline\n  protected _writeOne(inst: T, a: f64): void {\n    var buff = changetype<usize>(this._buffer);\n    var index: i32 = this._offset;\n    var next: i32 = index + 3;\n    STORE<f64>(buff, index, <f64>inst);\n    STORE<f64>(buff, index + 1, <f64>next);\n    STORE<f64>(buff, index + 2, a);\n    this._offset = next;\n  }\n\n  /**\n   * Write a single instruction to the buffer with two parameters. This results in four values\n   * written to the buffer.\n   *\n   * @param {T} inst - The instruction type to be written to the buffer.\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\n   */\n  @inline\n  protected _writeTwo(inst: T, a: f64, b: f64): void {\n    var buff = changetype<usize>(this._buffer);\n    var index: i32 = this._offset;\n    var next: i32 = index + 4;\n    STORE<f64>(buff, index, <f64>inst);\n    STORE<f64>(buff, index + 1, <f64>next);\n    STORE<f64>(buff, index + 2, a);\n    STORE<f64>(buff, index + 3, b);\n    this._offset = next;\n  }\n\n  /**\n   * Write a single instruction to the buffer with three parameters. This results in five values\n   * written to the buffer.\n   *\n   * @param {T} inst - The instruction type to be written to the buffer.\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\n   */\n  @inline\n  protected _writeThree(inst: T, a: f64, b: f64, c: f64): void {\n    var buff = changetype<usize>(this._buffer);\n    var index: i32 = this._offset;\n    var next: i32 = index + 5;\n    STORE<f64>(buff, index, <f64>inst);\n    STORE<f64>(buff, index + 1, <f64>next);\n    STORE<f64>(buff, index + 2, a);\n    STORE<f64>(buff, index + 3, b);\n    STORE<f64>(buff, index + 4, c);\n    this._offset = next;\n  }\n\n  /**\n   * Write a single instruction to the buffer with four parameters. This results in six values\n   * written to the buffer.\n   *\n   * @param {T} inst - The instruction type to be written to the buffer.\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\n   */\n  @inline\n  protected _writeFour(inst: T, a: f64, b: f64, c: f64, d: f64): void {\n    var buff = changetype<usize>(this._buffer);\n    var index: i32 = this._offset;\n    var next: i32 = index + 6;\n    STORE<f64>(buff, index, <f64>inst);\n    STORE<f64>(buff, index + 1, <f64>next);\n    STORE<f64>(buff, index + 2, a);\n    STORE<f64>(buff, index + 3, b);\n    STORE<f64>(buff, index + 4, c);\n    STORE<f64>(buff, index + 5, d);\n    this._offset = next;\n  }\n\n  /**\n   * Write a single instruction to the buffer with five parameters. This results in seven values\n   * written to the buffer.\n   *\n   * @param {T} inst - The instruction type to be written to the buffer.\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\n   * @param {f64} d - The fifth parameter for the instruction to be written to the buffer.\n   */\n  @inline\n  protected _writeFive(inst: T, a: f64, b: f64, c: f64, d: f64, e: f64): void {\n    var buff = changetype<usize>(this._buffer);\n    var index: i32 = this._offset;\n    var next: i32 = index + 7;\n    STORE<f64>(buff, index, <f64>inst);\n    STORE<f64>(buff, index + 1, <f64>next);\n    STORE<f64>(buff, index + 2, a);\n    STORE<f64>(buff, index + 3, b);\n    STORE<f64>(buff, index + 4, c);\n    STORE<f64>(buff, index + 5, d);\n    STORE<f64>(buff, index + 6, e);\n    this._offset = next;\n  }\n\n  /**\n   * Write a single instruction to the buffer with six parameters. This results in eight values\n   * written to the buffer.\n   *\n   * @param {T} inst - The instruction type to be written to the buffer.\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\n   * @param {f64} e - The fifth parameter for the instruction to be written to the buffer.\n   * @param {f64} f - The sixth parameter for the instruction to be written to the buffer.\n   */\n  @inline\n  protected _writeSix(inst: T, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\n    var buff = changetype<usize>(this._buffer);\n    var index: i32 = this._offset;\n    var next: i32 = index + 8;\n    STORE<f64>(buff, index, <f64>inst);\n    STORE<f64>(buff, index + 1, <f64>next);\n    STORE<f64>(buff, index + 2, a);\n    STORE<f64>(buff, index + 3, b);\n    STORE<f64>(buff, index + 4, c);\n    STORE<f64>(buff, index + 5, d);\n    STORE<f64>(buff, index + 6, e);\n    STORE<f64>(buff, index + 7, f);\n    this._offset = next;\n  }\n\n  /**\n   * Write a single instruction to the buffer with eight parameters. This results in ten values\n   * written to the buffer.\n   *\n   * @param {T} inst - The instruction type to be written to the buffer.\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\n   * @param {f64} e - The fifth parameter for the instruction to be written to the buffer.\n   * @param {f64} f - The sixth parameter for the instruction to be written to the buffer.\n   * @param {f64} g - The seventh parameter for the instruction to be written to the buffer.\n   * @param {f64} h - The eighth parameter for the instruction to be written to the buffer.\n   */\n  @inline\n  protected _writeEight(inst: T, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64, g: f64, h: f64): void {\n    var buff = changetype<usize>(this._buffer);\n    var index: i32 = this._offset;\n    var next: i32 = index + 10;\n    STORE<f64>(buff, index, <f64>inst);\n    STORE<f64>(buff, index + 1, <f64>next);\n    STORE<f64>(buff, index + 2, a);\n    STORE<f64>(buff, index + 3, b);\n    STORE<f64>(buff, index + 4, c);\n    STORE<f64>(buff, index + 5, d);\n    STORE<f64>(buff, index + 6, e);\n    STORE<f64>(buff, index + 7, f);\n    STORE<f64>(buff, index + 8, g);\n    STORE<f64>(buff, index + 9, h);\n    this._offset = next;\n  }\n\n  /**\n   * Write a single instruction to the buffer with nine parameters. This results in eleven values\n   * written to the buffer.\n   *\n   * @param {T} inst - The instruction type to be written to the buffer.\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\n   * @param {f64} e - The fifth parameter for the instruction to be written to the buffer.\n   * @param {f64} f - The sixth parameter for the instruction to be written to the buffer.\n   * @param {f64} g - The seventh parameter for the instruction to be written to the buffer.\n   * @param {f64} h - The eighth parameter for the instruction to be written to the buffer.\n   * @param {f64} i - The ninth parameter for the instruction to be written to the buffer.\n   */\n  @inline\n  protected _writeNine(inst: T, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64, g: f64, h: f64, i: f64): void {\n    var buff = changetype<usize>(this._buffer);\n    var index: i32 = this._offset;\n    var next: i32 = index + 11;\n    STORE<f64>(buff, index, <f64>inst);\n    STORE<f64>(buff, index + 1, <f64>next);\n    STORE<f64>(buff, index + 2, a);\n    STORE<f64>(buff, index + 3, b);\n    STORE<f64>(buff, index + 4, c);\n    STORE<f64>(buff, index + 5, d);\n    STORE<f64>(buff, index + 6, e);\n    STORE<f64>(buff, index + 7, f);\n    STORE<f64>(buff, index + 8, g);\n    STORE<f64>(buff, index + 9, h);\n    STORE<f64>(buff, index + 10, i);\n    this._offset = next;\n  }\n\n  /**\n   * Reset the buffer back to position 0.\n   */\n  @inline\n  protected _resetBuffer(): void {\n    this._offset = 0;\n    let length = this._retainedOffset;\n    let pointer = changetype<usize>(this._retained);\n    for (let i = 0; i < length; i++) {\n      __release(load<usize>(pointer + (<usize>i << alignof<usize>())));\n    }\n    // all the pointers are released\n    this._retainedOffset = 0;\n  }\n\n  /**\n   * Retain a pointer in the buffer for later use.\n   *\n   * @param {usize} pointer - The pointer to be retained and released after the buffer is reset.\n   */\n  protected _retain(pointer: usize): void {\n    __retain(pointer);\n    var retained = changetype<usize>(this._retained);\n    var index = this._retainedOffset;\n    store<usize>(retained + (index << alignof<usize>()), pointer);\n    this._retainedOffset = index + 1;\n  }\n}\n","\n@unmanaged\nexport class StackPointer<T> {\n  static create<T>(count: i32): StackPointer<T> {\n    assert(!isManaged<T>());\n    assert(isReference<T>());\n    assert(count > 0);\n    let length = offsetof<T>() * count;\n    let ptr = __alloc(length, idof<ArrayBuffer>());\n    memory.fill(ptr, 0, length);\n    return changetype<StackPointer<T>>(ptr);\n  }\n\n  @inline\n  push(): StackPointer<T> {\n    let current = changetype<usize>(this);\n    let next = current + offsetof<T>();\n    memory.copy(next, current, offsetof<T>());\n    return changetype<StackPointer<T>>(next);\n  }\n\n  @inline @operator.prefix(\"++\")\n  increment(): StackPointer<T> {\n    return changetype<StackPointer<T>>(changetype<usize>(this) + offsetof<T>());\n  }\n\n  @inline @operator.prefix(\"--\")\n  decrement(): StackPointer<T> {\n    return changetype<StackPointer<T>>(changetype<usize>(this) - offsetof<T>());\n  }\n\n  @inline\n  pop(): StackPointer<T> {\n    return changetype<StackPointer<T>>(changetype<usize>(this) - offsetof<T>());\n  }\n\n  reference(): T {\n    return changetype<T>(this);\n  }\n\n  dereference(): usize {\n    return changetype<usize>(this);\n  }\n}\n","@inline\nexport function arraysEqual(left: Float64Array, right: Float64Array): bool {\n  var len: i32 = left.length;\n  var valid = true;\n  if (len == right.length) {\n    for (var i = 0; i < len; i++) {\n      if (unchecked(left[i]) != unchecked(right[i])) {\n        valid = false;\n        break;\n      }\n    }\n  } else {\n    valid = false;\n  }\n  return valid;\n}\n\n@inline\nexport function checkDoubleArray(value: Float64Array): Float64Array {\n  var len: i32 = value.length;\n  var double: bool = <bool>(len & 1);\n  var result: Float64Array = new Float64Array(double ? len * 2 : len);\n  var doublelen: i32;\n  var i: i32 = 0;\n  for (;i < len; ++i) {\n    unchecked(result[i] = value[i]);\n  }\n  if (double) {\n    doublelen = len << 1;\n    for(;i < doublelen; i++) {\n      unchecked(result[i] = value[i - len]);\n    }\n  }\n  return result;\n}\n\n// @ts-ignore: decorators *are* valid here\n@inline\nexport function STORE<T>(pointer: usize, index: i32, value: T): void {\n  store<T>(pointer + (index << alignof<T>()), value);\n}\n\n// @ts-ignore: decorators *are* valid here\n@inline\nexport function LOAD<T>(pointer: usize, index: i32): T {\n  return load<T>(pointer + (index << alignof<T>()));\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace } from \"./util/string\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\nimport { ArrayBufferView } from \"./arraybuffer\";\nimport { idof } from \"./builtins\";\n\n@sealed export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = BLOCK_MAXSIZE >>> alignof<u16>();\n\n  static fromCharCode(unit: i32, surr: i32 = -1): string {\n    var hasSur = surr > 0;\n    var out = __alloc(2 << i32(hasSur), idof<string>());\n    store<u16>(out, <u16>unit);\n    if (hasSur) store<u16>(out, <u16>surr, 2);\n    return changetype<string>(out); // retains\n  }\n\n  static fromCodePoint(code: i32): string {\n    assert(<u32>code <= 0x10FFFF);\n    var hasSur = code > 0xFFFF;\n    var out = __alloc(2 << i32(hasSur), idof<string>());\n    if (!hasSur) {\n      store<u16>(out, <u16>code);\n    } else {\n      code -= 0x10000;\n      let lo: u32 = (code & 0x3FF) + 0xDC00;\n      let hi: u32 = (code >>> 10) + 0xD800;\n      store<u32>(out, hi | (lo << 16));\n    }\n    return changetype<string>(out); // retains\n  }\n\n  get length(): i32 {\n    return changetype<BLOCK>(changetype<usize>(this) - BLOCK_OVERHEAD).rtSize >> 1;\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    var out = __alloc(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (undefined)\n    var first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if (first < 0xD800 || first > 0xDBFF || pos + 1 == this.length) return first;\n    var second = <i32>load<u16>(changetype<usize>(this) + ((<usize>pos + 1) << 1));\n    if (second < 0xDC00 || second > 0xDFFF) return first;\n    return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return select<String>(left, changetype<String>(\"null\"), left !== null).concat(right);\n  }\n\n  concat(other: String): String {\n    if (other === null) other = changetype<String>(\"null\");\n    var thisSize: isize = this.length << 1;\n    var otherSize: isize = other.length << 1;\n    var outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    var out = changetype<String>(__alloc(outSize, idof<String>())); // retains\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    if (search === null) return false;\n    end = min(max(end, 0), this.length);\n    var searchLength = <isize>search.length;\n    var searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n    var leftLength = left.length;\n    if (leftLength != right.length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return str === null || !str.length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String | null, right: String | null): bool {\n    if (left === right || left === null || right === null) return false;\n    var leftLength  = left.length;\n    var rightLength = right.length;\n    if (!leftLength)  return false;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    return compareImpl(left, 0, right, 0, min(leftLength, rightLength)) > 0;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n    var leftLength  = left.length;\n    var rightLength = right.length;\n    if (!rightLength) return false;\n    if (!leftLength)  return true;\n    // @ts-ignore: string <-> String\n    return compareImpl(left, 0, right, 0, min(leftLength, rightLength)) < 0;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    var len = <isize>this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    var len = this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    if (search === null) search = changetype<String>(\"null\");\n    var len = <isize>this.length;\n    var searchStart = min(max(<isize>start, 0), len);\n    var searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    var intStart: isize = start;\n    var end: isize = length;\n    var size: isize = this.length;\n    if (intStart < 0) intStart = max(size + intStart, 0);\n    var resultLength = min(max(end, 0), size - intStart);\n    if (resultLength <= 0) return changetype<String>(\"\");\n    var out = __alloc(resultLength << 1, idof<String>());\n    memory.copy(out, changetype<usize>(this) + intStart, resultLength);\n    return changetype<String>(out); // retains\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len: isize = this.length;\n    var finalStart = min<isize>(max(start, 0), len);\n    var finalEnd = min<isize>(max(end, 0), len);\n    var fromPos = min<isize>(finalStart, finalEnd) << 1;\n    var toPos = max<isize>(finalStart, finalEnd) << 1;\n    len = toPos - fromPos;\n    if (!len) return changetype<String>(\"\");\n    if (!fromPos && toPos == this.length << 1) return this;\n    var out = __alloc(len, idof<String>());\n    memory.copy(out, changetype<usize>(this) + fromPos, len);\n    return changetype<String>(out); // retains\n  }\n\n  trim(): String {\n    var length = this.length;\n    var size: usize = length << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == length << 1) return this;\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + offset, size);\n    return changetype<String>(out); // retains\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    var size = <usize>this.length << 1;\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + offset, size);\n    return changetype<String>(out); // retains\n  }\n\n  trimEnd(): String {\n    var originalSize = <usize>this.length << 1;\n    var size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this), size);\n    return changetype<String>(out); // retains\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var prependSize = targetSize - thisSize;\n    var out = __alloc(targetSize, idof<String>());\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(out, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(out + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(out, changetype<usize>(pad), prependSize);\n    }\n    memory.copy(out + prependSize, changetype<usize>(this), thisSize);\n    return changetype<String>(out); //  retains\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var appendSize = targetSize - thisSize;\n    var out = __alloc(targetSize, idof<String>());\n    memory.copy(out, changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(out + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(out + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(out + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return changetype<String>(out); // retains\n  }\n\n  repeat(count: i32 = 0): String {\n    var length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    var out = __alloc((length * count) << 1, idof<String>());\n    memory.repeat(out, changetype<usize>(this), <usize>length << 1, count);\n    return changetype<String>(out); // retains\n  }\n\n  replace(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = __alloc(olen << 1, idof<String>());\n        memory.copy(out, changetype<usize>(this), index << 1);\n        memory.copy(\n          out + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          out + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return changetype<String>(out);\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var rlen: usize = replacement.length;\n    if (!slen) {\n      if (!rlen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = __alloc((len + (len + 1) * rlen) << 1, idof<String>());\n      memory.copy(out, changetype<usize>(replacement), rlen << 1);\n      let offset = rlen;\n      for (let i: usize = 0; i < len; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          out + (offset << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        offset += rlen;\n      }\n      return changetype<String>(out);\n    }\n    var prev: isize = 0, next: isize = 0;\n    if (slen == rlen) {\n      // Fast path when search and replacement have same length\n      let size = len << 1;\n      let out = __alloc(size, idof<String>());\n      memory.copy(out, changetype<usize>(this), size);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(out + (next << 1), changetype<usize>(replacement), rlen << 1);\n        prev = next + slen;\n      }\n      return changetype<String>(out);\n    }\n    var out: usize = 0, offset: usize = 0, resLen = len;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = __alloc(len << 1, idof<String>());\n      if (offset > resLen) {\n        let newLength = resLen << 1;\n        out = __realloc(out, newLength << 1);\n        resLen = newLength;\n      }\n      let chunk = next - prev;\n      memory.copy(\n        out + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        out + (offset << 1),\n        changetype<usize>(replacement),\n        rlen << 1\n      );\n      offset += rlen;\n      prev = next + slen;\n    }\n    if (offset) {\n      if (offset > resLen) {\n        let newLength = resLen << 1;\n        out = __realloc(out, newLength << 1);\n        resLen = newLength;\n      }\n      let rest = len - prev;\n      if (rest) {\n        memory.copy(\n          out + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (resLen > rest) out = __realloc(out, rest << 1);\n      return changetype<String>(out);\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    var out = __alloc(len << 1, idof<String>());\n    memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return changetype<String>(out); // retains\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>())); // retains\n    if (separator === null) return <String[]>[this];\n    var length: isize = this.length;\n    var sepLen: isize = separator.length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>()));  // retains\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = __allocArray(length, alignof<String>(), idof<Array<String>>());\n      let resultStart = changetype<ArrayBufferView>(result).dataStart;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = __alloc(2, idof<String>());\n        store<u16>(charStr, load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), charStr); // result[i] = charStr\n        if (isManaged<String>()) __retain(charStr);\n      }\n      return changetype<Array<String>>(result); // retains\n    } else if (!length) {\n      let result = __allocArray(1, alignof<String>(), idof<Array<String>>());\n      store<usize>(changetype<ArrayBufferView>(result).dataStart, changetype<usize>(\"\")); // static \"\"\n      return changetype<Array<String>>(result); // retains\n    }\n    var result = changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>())); // retains\n    var end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(separator, start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = __alloc(<usize>len << 1, idof<String>());\n        memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(changetype<String>(out));\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return changetype<Array<String>>(result); // retains\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return changetype<Array<String>>(result); // retains\n    }\n    var len = length - start;\n    if (len > 0) {\n      let out = __alloc(<usize>len << 1, idof<String>());\n      memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(changetype<String>(out)); // retains\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return changetype<Array<String>>(result); // retains\n    // releases result\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      var strOff = changetype<usize>(str);\n      var strEnd = strOff + <usize>changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n      var bufLen = nullTerminated ? 1 : 0;\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          if (nullTerminated && !c1) break;\n          bufLen += 1; strOff += 2;\n        } else if (c1 < 2048) {\n          bufLen += 2; strOff += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              strOff += 4; bufLen += 4;\n              continue;\n            }\n          }\n          strOff += 2; bufLen += 3;\n        }\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false): ArrayBuffer {\n      var strOff = changetype<usize>(str);\n      var strEnd = changetype<usize>(str) + <usize>changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n      var buf = __alloc(UTF8.byteLength(str, nullTerminated), idof<ArrayBuffer>());\n      var bufOff = buf;\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          if (nullTerminated && !c1) break;\n          store<u8>(bufOff, c1);\n          bufOff += 1; strOff += 2;\n        } else if (c1 < 2048) {\n          store<u8>(bufOff, c1 >> 6      | 192);\n          store<u8>(bufOff, c1      & 63 | 128, 1);\n          bufOff += 2; strOff += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            let c2 = <u32>load<u16>(strOff, 2);\n            if ((c2 & 0xFC00) == 0xDC00) {\n              c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n              store<u8>(bufOff, c1 >> 18      | 240);\n              store<u8>(bufOff, c1 >> 12 & 63 | 128, 1);\n              store<u8>(bufOff, c1 >> 6  & 63 | 128, 2);\n              store<u8>(bufOff, c1       & 63 | 128, 3);\n              strOff += 4; bufOff += 4;\n              continue;\n            }\n          }\n          store<u8>(bufOff, c1 >> 12      | 224);\n          store<u8>(bufOff, c1 >> 6  & 63 | 128, 1);\n          store<u8>(bufOff, c1       & 63 | 128, 2);\n          strOff += 2; bufOff += 3;\n        }\n      }\n      if (nullTerminated) {\n        assert(strOff <= strEnd);\n        buf = __realloc(buf, bufOff - buf + 1);\n        store<u8>(bufOff, 0);\n      } else {\n        assert(strOff == strEnd);\n      }\n      return changetype<ArrayBuffer>(buf); // retains\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): string {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): string {\n      var bufOff = buf;\n      var bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      var str = __alloc(len << 1, idof<string>()); // max is one u16 char per u8 byte\n      var strOff = str;\n      while (bufOff < bufEnd) {\n        let cp = <u32>load<u8>(bufOff++);\n        if (cp < 128) {\n          if (nullTerminated && !cp) break;\n          store<u16>(strOff, cp);\n          strOff += 2;\n        } else if (cp > 191 && cp < 224) {\n          if (bufEnd - bufOff < 1) break;\n          store<u16>(strOff, (cp & 31) << 6 | load<u8>(bufOff++) & 63);\n          strOff += 2;\n        } else if (cp > 239 && cp < 365) {\n          if (bufEnd - bufOff < 3) break;\n          cp = (\n            (cp                  &  7) << 18 |\n            (load<u8>(bufOff)    & 63) << 12 |\n            (load<u8>(bufOff, 1) & 63) << 6  |\n             load<u8>(bufOff, 2) & 63\n          ) - 0x10000;\n          bufOff += 3;\n          store<u16>(strOff, 0xD800 + (cp >> 10));\n          store<u16>(strOff, 0xDC00 + (cp & 1023), 2);\n          strOff += 4;\n        } else {\n          if (bufEnd - bufOff < 2) break;\n          store<u16>(strOff,\n            (cp                  & 15) << 12 |\n            (load<u8>(bufOff)    & 63) << 6  |\n             load<u8>(bufOff, 1) & 63\n          );\n          bufOff += 2; strOff += 2;\n        }\n      }\n      return changetype<string>(__realloc(str, strOff - str)); // retains\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      var size = changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n      var buf = __alloc(size, idof<ArrayBuffer>());\n      memory.copy(buf, changetype<usize>(str), <usize>size);\n      return changetype<ArrayBuffer>(buf); // retains\n    }\n\n    export function decode(buf: ArrayBuffer): string {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): string {\n      var str = __alloc(len &= ~1, idof<string>());\n      memory.copy(str, buf, len);\n      return changetype<string>(str); // retains\n    }\n  }\n}\n","// @ts-ignore\n@external(\"__canvas_sys\", \"loadImage\")\ndeclare function loadImage(img: Image, src: string): i32;\n\n// @ts-ignore\n@external(\"__canvas_sys\", \"disposeImage\")\ndeclare function disposeImage(id: i32): void;\n\nexport class Image {\n  private _id: i32 = -1;\n  private _width: i32 = 0;\n  private _height: i32 = 0;\n  private _loaded: bool = false;\n  private _src: string = \"\";\n\n  @inline\n  public get width(): number {\n    return this._width;\n  }\n\n  @inline\n  public get height(): number {\n    return this._height;\n  }\n\n  @inline\n  public get loaded(): bool {\n    return this._loaded;\n  }\n\n  @inline\n  public get src(): string {\n    return this._src;\n  }\n\n  public set src(value: string) {\n    this._src = value;\n    this._id = loadImage(this, value);\n  }\n\n  public dispose(): void {\n    disposeImage(this._id);\n  }\n}\n\nexport function __image_loaded(img: Image, width: i32, height: i32): void {\n  store<i32>(changetype<usize>(img) + offsetof<Image>(\"_width\"), width);\n  store<i32>(changetype<usize>(img) + offsetof<Image>(\"_height\"), height);\n  store<bool>(changetype<usize>(img) + offsetof<Image>(\"_loaded\"), true);\n}\n\n/**\n * Gets the image's external id.\n *\n * @param image - The target image.\n */\n// @ts-ignore: @inline is valid on regular functions\n@inline\nexport function getImageID(image: Image): i32 {\n  return load<i32>(changetype<usize>(image) + offsetof<Image>(\"_id\"));\n}\n","import {\n  CanvasDirection,\n  CanvasGradient,\n  CanvasPattern,\n  CanvasPatternRepetition,\n  CanvasRenderingContext2D,\n  FillRule,\n  GlobalCompositeOperation,\n  Image,\n  ImageSmoothingQuality,\n  LineCap,\n  LineJoin,\n  TextAlign,\n  TextBaseline,\n  getContextById,\n } from \"./index\";\n\nvar ctx: CanvasRenderingContext2D;\nvar grd: CanvasGradient;\nvar img: Image | null = null;\nvar ptrn: CanvasPattern;\n\nexport function arc(x: number, y: number, r: number, startAngle: number, endAngle: number, anticlockwise: bool): void {\n  assert(ctx);\n  ctx.arc(x, y, r, startAngle, endAngle, anticlockwise);\n}\n\nexport function init(): void {\n  ctx = getContextById(\"main\");\n}\n\nexport function fillStyle(value: string): void {\n  assert(ctx);\n  ctx.fillStyle = value;\n}\n\nexport function strokeStyle(value: string): void {\n  assert(ctx);\n  ctx.strokeStyle = value;\n}\n\nexport function fill(fillRule: FillRule = FillRule.nonzero): void {\n  assert(ctx);\n  ctx.fill(fillRule);\n}\n\nexport function stroke(): void {\n  assert(ctx);\n  ctx.stroke();\n}\n\nexport function commit(): void {\n  assert(ctx);\n  ctx.commit();\n}\n\nexport function filter(str: string): void {\n  assert(ctx);\n  ctx.filter = str;\n}\n\nexport function globalAlpha(value: f64): void {\n  assert(ctx);\n  ctx.globalAlpha = value;\n}\n\nexport function imageSmoothingEnabled(value: bool): void {\n  assert(ctx);\n  ctx.imageSmoothingEnabled = value;\n}\n\nexport function imageSmoothingQuality(value: ImageSmoothingQuality): void {\n  assert(ctx);\n  ctx.imageSmoothingQuality = value;\n}\n\nexport function shadowBlur(value: f64): void {\n  assert(ctx);\n  ctx.shadowBlur = value;\n}\n\nexport function shadowColor(value: string): void {\n  assert(ctx);\n  ctx.shadowColor = value;\n}\n\nexport function shadowOffsetY(value: f64): void {\n  assert(ctx);\n  ctx.shadowOffsetY = value;\n}\n\nexport function shadowOffsetX(value: f64): void {\n  assert(ctx);\n  ctx.shadowOffsetX = value;\n}\n\nexport function createRadialGradient(x0: f64, y0: f64, r0: f64, x1: f64, y1: f64, r1: f64): i32 {\n  assert(ctx);\n  grd = ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);\n  assert(grd);\n  return load<i32>(changetype<usize>(grd) + offsetof<CanvasGradient>(\"id\"));\n}\n\nexport function fillGradient(): void {\n  assert(ctx);\n  assert(grd);\n  ctx.fillGradient = grd;\n}\n\nexport function strokeGradient(): void {\n  assert(ctx);\n  assert(grd);\n  ctx.strokeGradient = grd;\n}\n\nexport function createImage(): i32 {\n  img = new Image();\n  assert(img);\n  img.src = \"http://placekitten.com/400/300\";\n  return load<i32>(changetype<usize>(img) + offsetof<Image>(\"_id\"));\n}\n\nexport function createPattern(): i32 {\n  assert(ctx);\n  assert(img);\n  assert(img.loaded);\n  ptrn = ctx.createPattern(img!, CanvasPatternRepetition.repeat);\n  return load<i32>(changetype<usize>(ptrn) + offsetof<CanvasPattern>(\"id\"));\n}\n\nexport function fillPattern(): void {\n  assert(ctx);\n  assert(ptrn);\n  ctx.fillPattern = ptrn;\n}\n\nexport function strokePattern(): void {\n  assert(ctx);\n  assert(ptrn);\n  ctx.strokePattern = ptrn;\n}\n\nexport function setTransform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\n  assert(ctx);\n  ctx.setTransform(a, b, c, d, e, f);\n}\n\nexport function clearRect(x: f64, y: f64, width: f64, height: f64): void {\n  assert(ctx);\n  ctx.clearRect(x, y, width, height);\n}\n\nexport function arcTo(x1: f64, y1: f64, x2: f64, y2: f64, radius: f64): void {\n  assert(ctx);\n  ctx.arcTo(x1, y1, x2, y2, radius);\n}\n\nexport function bezierCurveTo(cp1x: f64, cp1y: f64, cp2x: f64, cp2y: f64, x: f64, y: f64): void {\n  assert(ctx);\n  ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n}\n\nexport function clip(): void {\n  assert(ctx);\n  ctx.clip();\n}\n\nexport function closePath(): void {\n  assert(ctx);\n  ctx.closePath();\n}\n\nexport function ellipse(x: f64, y: f64, radiusX: f64, radiusY: f64, rotation: f64, startAngle: f64, endAngle: f64, anticlockwise: bool): void {\n  assert(ctx);\n  ctx.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);\n}\n\nexport function lineTo(x: f64, y: f64): void {\n  assert(ctx);\n  ctx.lineTo(x, y);\n}\n\nexport function moveTo(x: f64, y: f64): void {\n  assert(ctx);\n  ctx.moveTo(x, y);\n}\n\nexport function quadraticCurveTo(cpx: f64, cpy: f64, x: f64, y: f64): void {\n  assert(ctx);\n  ctx.quadraticCurveTo(cpx, cpy, x, y);\n}\n\nexport function rect(x: f64, y: f64, width: f64, height: f64): void {\n  assert(ctx);\n  ctx.rect(x, y, width, height);\n}\n\nexport function globalCompositeOperation(operation: GlobalCompositeOperation): void {\n  assert(ctx);\n  ctx.globalCompositeOperation = operation;\n}\n\nexport function fillRect(x: f64, y: f64, width: f64, height: f64): void {\n  assert(ctx);\n  ctx.fillRect(x, y, width, height);\n}\n\nexport function drawImage(dx: f64, dy: f64): void {\n  assert(ctx);\n  ctx.drawImage(img, dx, dy);\n}\n\nexport function drawImageSize(dx: f64, dy: f64, dWidth: f64, dHeight: f64): void {\n  assert(ctx);\n  ctx.drawImageSize(img, dx, dy, dWidth, dHeight);\n}\n\nexport function drawImageSource(sx: f64, sy: f64, sWidth: f64, sHeight: f64, dx: f64, dy: f64, dWidth: f64, dHeight: f64): void {\n  assert(ctx);\n  ctx.drawImageSource(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n}\n\nexport function fillText(text: string, x: f64, y: f64): void {\n  assert(ctx);\n  ctx.fillText(text, x, y);\n}\n\nexport function fillTextWidth(text: string, x: f64, y: f64, width: f64): void {\n  assert(ctx);\n  ctx.fillTextWidth(text, x, y, width);\n}\n\nexport function direction(value: CanvasDirection): void {\n  assert(ctx);\n  ctx.direction = value;\n}\n\nexport function font(value: string): void {\n  assert(ctx);\n  ctx.font = value;\n}\n\nexport function textAlign(value: TextAlign): void {\n  assert(ctx);\n  ctx.textAlign = value;\n}\n\nexport function textBaseline(value: TextBaseline): void {\n  assert(ctx);\n  ctx.textBaseline = value;\n}\n\nexport function measureText(value: string): f64 {\n  assert(ctx);\n  return ctx.measureText(value);\n}\n\nexport function lineCap(value: LineCap): void {\n  assert(ctx);\n  ctx.lineCap = value;\n}\n\nexport function setLineDash(a: f64, b: f64, c: f64): void {\n  assert(ctx);\n  var array = new Float64Array(3);\n  array[0] = a;\n  array[1] = b;\n  array[2] = c;\n  ctx.setLineDash(array);\n}\n\nexport function lineDashOffset(value: f64): void {\n  assert(ctx);\n  ctx.lineDashOffset = value;\n}\n\nexport function lineJoin(value: LineJoin): void {\n  assert(ctx);\n  ctx.lineJoin = value;\n}\n\nexport function lineWidth(value: f64): void {\n  assert(ctx);\n  ctx.lineWidth = value;\n}\n\nexport function miterLimit(value: f64): void {\n  assert(ctx);\n  ctx.miterLimit = value;\n}\n\nexport function strokeRect(x: f64, y: f64, width: f64, height: f64): void {\n  assert(ctx);\n  ctx.strokeRect(x, y, width, height);\n}\n\nexport function strokeText(text: string, x: f64, y: number): void {\n  assert(ctx);\n  ctx.strokeText(text, x, y);\n}\n\nexport function strokeTextWidth(text: string, x: f64, y: f64, width: f64): void {\n  assert(ctx);\n  ctx.strokeTextWidth(text, x, y, width);\n}\n\nexport function save(hard: bool): void {\n  assert(ctx);\n  ctx.save(hard);\n}\n\nexport function restore(): void {\n  assert(ctx);\n  ctx.restore();\n}\n\nexport function imageNull(): void {\n  // @ts-ignore\n  img = null;\n}\n\nexport function rotate(angle: f64): void {\n  assert(ctx);\n  ctx.rotate(angle);\n}\n\nexport function scale(x: f64, y: f64): void {\n  assert(ctx);\n  ctx.scale(x, y);\n}\n\nexport function transform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\n  assert(ctx);\n  ctx.transform(a, b, c, d, e, f);\n}\n\nexport function translate(x: f64, y: f64): void {\n  assert(ctx);\n  ctx.translate(x, y);\n}\n","// @ts-ignore: decorators are valid here\n@external(\"__canvas_sys\", \"addColorStop\")\ndeclare function addColorStop(id: i32, offset: f64, color: string): void;\n\n// @ts-ignore: decorators are valid here\n@external(\"__canvas_sys\", \"disposeCanvasGradient\")\ndeclare function disposeCanvasGradient(id: i32): void;\n\n/**\n * The CanvasGradient interface represents an opaque object describing a gradient. It is returned\n * by the methods CanvasRenderingContext2D.createLinearGradient() or\n * CanvasRenderingContext2D.createRadialGradient().\n *\n * It can be used as a fillGradient or strokeGradient.\n */\nexport class CanvasGradient {\n  private id: i32 = -1;\n\n  /**\n   * The CanvasGradient.addColorStop() method adds a new color stop, defined by an offset and a\n   * color, to a given canvas gradient.\n   *\n   * @param {f64} offset - A number between 0 and 1, inclusive, representing the position of the\n   * color stop. 0 represents the start of the gradient and 1 represents the end; an INDEX_SIZE_ERR\n   * is raised if the number is outside that range. This number is clamped to the inclusive [0,1]\n   * range before it is passed to the browser.\n   * @param {string} color - A CSS <color> value representing the color of the stop. A SYNTAX_ERR is\n   * raised if the value cannot be parsed as a CSS <color> value.\n   */\n  public addColorStop(offset: f64, color: string): void {\n    addColorStop(this.id, max<f64>(min(offset, 0.0), 1.0), color);\n  }\n\n  /**\n   * This method frees the CanvasGradient from the host's gradient index.\n   */\n  public dispose(): void {\n    disposeCanvasGradient(this.id);\n  }\n}","// @ts-ignore\n@external(\"__canvas_sys\", \"disposeCanvasPattern\")\ndeclare function disposeCanvasPattern(id: i32): void;\n\n/**\n * The CanvasPattern interface represents an opaque object describing a pattern, based on an image,\n * a canvas, or a video, created by the CanvasRenderingContext2D.createPattern() method.\n */\nexport class CanvasPattern {\n  private id: i32 = -1;\n\n\n  /**\n   * This method frees the CanvasPattern from the host's pattern index.\n   */\n  public dispose(): void {\n    disposeCanvasPattern(this.id);\n  }\n}\n","// @ts-ignore: decorator\n@builtin\nexport declare function isInteger<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFloat<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isBoolean<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isSigned<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isReference<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isString<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArray<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArrayLike<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFunction<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNullable<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isDefined(expression: void): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isConstant(expression: void): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isManaged<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVoid<T>(): boolean;\n\n// @ts-ignore\n@builtin\nexport declare function lengthof<T>(func?: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function clz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function abs<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function floor<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function nearest<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function reinterpret<T>(value: number): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function store<T>(ptr: usize, value: void, immOffset?: usize, immAlign?: usize): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function alignof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function idof<T>(): u32;\n\n// @ts-ignore\n@builtin\nexport declare function nameof<T>(): string;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unreachable(): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function changetype<T>(value: void): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unchecked<T>(expr: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function call_indirect<T>(target: void, ...args: void[]): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function call_direct<T>(target: void, ...args: void[]): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function instantiate<T>(...args: void[]): T;\n\nexport namespace atomic {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load<T>(ptr: usize, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function notify(ptr: usize, count: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function fence(): void;\n}\n\n// @ts-ignore: decorator\n@lazy\nexport const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8(value: void): i8;\n\nexport namespace i8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i8 = -128;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i8 =  127;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16(value: void): i16;\n\nexport namespace i16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i16 = -32768;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i16 =  32767;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32(value: void): i32;\n\nexport namespace i32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i32 = -2147483648;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i32 =  2147483647;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f32(value: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64(value: void): i64;\n\nexport namespace i64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i64 = -9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i64 =  9223372036854775807;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f64(value: f64): i64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load32_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw32 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isize(value: void): isize;\n\nexport namespace isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u8(value: void): u8;\n\nexport namespace u8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u8 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u8 = 255;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u16(value: void): u16;\n\nexport namespace u16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u16 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u16 = 65535;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u32(value: void): u32;\n\nexport namespace u32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u32 = 4294967295;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u64(value: void): u64;\n\nexport namespace u64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u64 = 18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function usize(value: void): usize;\n\nexport namespace usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: usize = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function bool(value: void): bool;\n\nexport namespace bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: bool = false;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: bool = true;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32(value: void): f32;\n\nexport namespace f32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f32, y: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i32(value: i32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f32): f32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64(value: void): f64;\n\nexport namespace f64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f64, y: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i64(value: i64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f64): f64;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function v128(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace v128 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat<T>(x: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul<T>(a: v128, b: v128): v128; // except i64\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function andnot(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function not(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfma<T>(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfms<T>(v1: v128, v2: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8x16(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace i8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_u(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\n\nexport namespace i16x8 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\n\nexport namespace i32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64x2(a: i64, b: i64): v128;\n\nexport namespace i64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\n\nexport namespace f32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfma(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfms(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64x2(a: f64, b: f64): v128;\n\nexport namespace f64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i64x2_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i64x2_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfma(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfms(a: v128, b: v128, c: v128): v128;\n}\n\nexport namespace v8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\nexport namespace v16x8 {\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\nexport namespace v32x4 {\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\nexport namespace v64x2 {\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n// @ts-ignore: decorator\n@external(\"env\", \"abort\")\ndeclare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"trace\")\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n","import * as JSMath from \"./bindings/Math\";\nexport { JSMath };\n\nimport {\n  abs as builtin_abs,\n  ceil as builtin_ceil,\n  clz as builtin_clz,\n  copysign as builtin_copysign,\n  floor as builtin_floor,\n  max as builtin_max,\n  min as builtin_min,\n  sqrt as builtin_sqrt,\n  trunc as builtin_trunc\n} from \"./builtins\";\n\n// SUN COPYRIGHT NOTICE\n//\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n// Developed at SunPro, a Sun Microsystems, Inc. business.\n// Permission to use, copy, modify, and distribute this software\n// is freely granted, provided that this notice is preserved.\n//\n// Applies to all functions marked with a comment referring here.\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy\nvar rempio2_y0: f64,\n    rempio2_y1: f64,\n    res128_hi: u64;\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy\nconst PIO2_TABLE: u64[] = [\n  0x00000000A2F9836E, 0x4E441529FC2757D1, 0xF534DDC0DB629599, 0x3C439041FE5163AB,\n  0xDEBBC561B7246E3A, 0x424DD2E006492EEA, 0x09D1921CFE1DEB1C, 0xB129A73EE88235F5,\n  0x2EBB4484E99C7026, 0xB45F7E413991D639, 0x835339F49C845F8B, 0xBDF9283B1FF897FF,\n  0xDE05980FEF2F118B, 0x5A0A6D1F6D367ECF, 0x27CB09B74F463F66, 0x9E5FEA2D7527BAC7,\n  0xEBE5F17B3D0739F7, 0x8A5292EA6BFB5FB1, 0x1F8D5D0856033046, 0xFC7B6BABF0CFBC20,\n  0x9AF4361DA9E39161, 0x5EE61B086599855F, 0x14A068408DFFD880, 0x4D73273106061557\n];\n\n/** @internal */\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\n  var p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\n  var q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\n  return p / q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction expo2(x: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                       // see: musl/src/math/__expo2.c\n    k    = <u32>2043,\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\n  var scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\n  return NativeMath.exp(x - kln2) * scale * scale;\n}\n\n/** @internal */\n/* Helper function to eventually get bits of π/2 * |x|\n *\n * y = π/4 * (frac << clz(frac) >> 11)\n * return clz(frac)\n *\n * Right shift 11 bits to make upper half fit in `double`\n */\n// @ts-ignore: decorator\n@inline\nfunction pio2_right(q0: u64, q1: u64): u64 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  /* Bits of π/4 */\n  const p0: u64 = 0xC4C6628B80DC1CD1;\n  const p1: u64 = 0xC90FDAA22168C234;\n\n  const Ox1p_64 = reinterpret<f64>(0x3BF0000000000000); // 0x1p-64\n  const Ox1p_75 = reinterpret<f64>(0x3B40000000000000); // 0x1p-75\n\n  var shift = clz(q1);\n\n  q1 = q1 << shift | q0 >> (64 - shift);\n  q0 <<= shift;\n\n  var lo = umuldi(p1, q1);\n  var hi = res128_hi;\n\n  var ahi = hi >> 11;\n  var alo = lo >> 11 | hi << 53;\n  var blo = <u64>(Ox1p_75 * <f64>p0 * <f64>q1 + Ox1p_75 * <f64>p1 * <f64>q0);\n\n  rempio2_y0 = <f64>(ahi + u64(lo < blo));\n  rempio2_y1 = Ox1p_64 * <f64>(alo + blo);\n\n  return shift;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction umuldi(u: u64, v: u64): u64 {\n  var u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;\n\n  u1 = u & 0xFFFFFFFF;\n  v1 = v & 0xFFFFFFFF;\n\n  u >>= 32;\n  v >>= 32;\n\n  t  = u1 * v1;\n  w0 = t & 0xFFFFFFFF;\n  t  = u * v1 + (t >> 32);\n  w1 = t >> 32;\n  t  = u1 * v + (t & 0xFFFFFFFF);\n\n  res128_hi = u * v + w1 + (t >> 32);\n  return (t << 32) + w0;\n}\n\n/** @internal */\nfunction pio2_large_quot(x: f64, u: i64): i32 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  const bits = PIO2_TABLE.dataStart;\n\n  var magnitude = u & 0x7FFFFFFFFFFFFFFF;\n  var offset = (magnitude >> 52) - 1045;\n  var shift  = offset & 63;\n  var tblPtr = bits + (<i32>(offset >> 6) << 3);\n  var s0: u64, s1: u64, s2: u64;\n\n  var b0 = load<u64>(tblPtr, 0 << 3);\n  var b1 = load<u64>(tblPtr, 1 << 3);\n  var b2 = load<u64>(tblPtr, 2 << 3);\n\n  /* Get 192 bits of 0x1p-31 / π with `offset` bits skipped */\n  if (shift) {\n    let rshift = 64 - shift;\n    let b3 = load<u64>(tblPtr, 3 << 3);\n    s0 = b1 >> rshift | b0 << shift;\n    s1 = b2 >> rshift | b1 << shift;\n    s2 = b3 >> rshift | b2 << shift;\n  } else {\n    s0 = b0;\n    s1 = b1;\n    s2 = b2;\n  }\n\n  var significand = (u & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;\n\n  /* First 128 bits of fractional part of x/(2π) */\n  var blo = umuldi(s1, significand);\n  var bhi = res128_hi;\n\n  var ahi = s0 * significand;\n  var clo = (s2 >> 32) * (significand >> 32);\n  var plo = blo + clo;\n  var phi = ahi + bhi + u64(plo < clo);\n\n  // r: u128 = p << 2\n  var rlo = plo << 2;\n  var rhi = phi << 2 | plo >> 62;\n\n  // s: i128 = r >> 127\n  var slo = <i64>rhi >> 63;\n  var shi = slo >> 1;\n  var q   = (<i64>phi >> 62) - slo;\n\n  var shifter = 0x3CB0000000000000 - (pio2_right(rlo ^ slo, rhi ^ shi) << 52);\n  var signbit = (u ^ rhi) & 0x8000000000000000;\n  var coeff = reinterpret<f64>(shifter | signbit);\n\n  rempio2_y0 *= coeff;\n  rempio2_y1 *= coeff;\n\n  return <i32>q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction rempio2(x: f64, u: u64, sign: i32): i32 {\n  const pio2_1  = reinterpret<f64>(0x3FF921FB54400000); // 1.57079632673412561417e+00\n  const pio2_1t = reinterpret<f64>(0x3DD0B4611A626331); // 6.07710050650619224932e-11\n  const pio2_2  = reinterpret<f64>(0x3DD0B4611A600000); // 6.07710050630396597660e-11\n  const pio2_2t = reinterpret<f64>(0x3BA3198A2E037073); // 2.02226624879595063154e-21\n  const pio2_3  = reinterpret<f64>(0x3BA3198A2E000000); // 2.02226624871116645580e-21\n  const pio2_3t = reinterpret<f64>(0x397B839A252049C1); // 8.47842766036889956997e-32\n  const invpio2 = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  var ix = <u32>(u >> 32) & 0x7FFFFFFF;\n\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (ix < 0x4002D97C) { /* |x| < 3pi/4, special case with n=+-1 */\n      let q = 1, z: f64, y0: f64, y1: f64;\n      if (!sign) {\n        z = x - pio2_1;\n        if (ix != 0x3FF921FB) { /* 33+53 bit pi is good enough */\n          y0 = z - pio2_1t;\n          y1 = (z - y0) - pio2_1t;\n        } else { /* near pi/2, use 33+33+53 bit pi */\n          z -= pio2_2;\n          y0 = z - pio2_2t;\n          y1 = (z - y0) - pio2_2t;\n        }\n      } else { /* negative x */\n        z = x + pio2_1;\n        if (ix != 0x3FF921FB) { /* 33+53 bit pi is good enough */\n          y0 = z + pio2_1t;\n          y1 = (z - y0) + pio2_1t;\n        } else { /* near pi/2, use 33+33+53 bit pi */\n          z += pio2_2;\n          y0 = z + pio2_2t;\n          y1 = (z - y0) + pio2_2t;\n        }\n        q = -1;\n      }\n      rempio2_y0 = y0;\n      rempio2_y1 = y1;\n      return q;\n    }\n  }\n\n  if (ix < 0x413921FB) { // |x| ~< 2^20*pi/2 (1647099)\n    // Use precise Cody Waite scheme\n    let q  = nearest(x * invpio2);\n    let r  = x - q * pio2_1;\n    let w  = q * pio2_1t; // 1st round good to 85 bit\n    let j  = ix >> 20;\n    let y0 = r - w;\n    let hi = <u32>(reinterpret<u64>(y0) >> 32);\n    let i  = j - ((hi >> 20) & 0x7FF);\n\n    if (i > 16) { // 2nd iteration needed, good to 118\n      let t = r;\n      w  = q * pio2_2;\n      r  = t - w;\n      w  = q * pio2_2t - ((t - r) - w);\n      y0 = r - w;\n      hi = <u32>(reinterpret<u64>(y0) >> 32);\n      i = j - ((hi >> 20) & 0x7FF);\n      if (i > 49) { // 3rd iteration need, 151 bits acc\n        let t = r;\n        w  = q * pio2_3;\n        r  = t - w;\n        w  = q * pio2_3t - ((t - r) - w);\n        y0 = r - w;\n      }\n    }\n    let y1 = (r - y0) - w;\n    rempio2_y0 = y0;\n    rempio2_y1 = y1;\n    return <i32>q;\n  }\n  var q = pio2_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction sin_kern(x: f64, y: f64, iy: i32): f64 { // see: musl/tree/src/math/__sin.c\n  const S1 = reinterpret<f64>(0xBFC5555555555549); // -1.66666666666666324348e-01\n  const S2 = reinterpret<f64>(0x3F8111111110F8A6); //  8.33333333332248946124e-03\n  const S3 = reinterpret<f64>(0xBF2A01A019C161D5); // -1.98412698298579493134e-04\n  const S4 = reinterpret<f64>(0x3EC71DE357B1FE7D); //  2.75573137070700676789e-06\n  const S5 = reinterpret<f64>(0xBE5AE5E68A2B9CEB); // -2.50507602534068634195e-08\n  const S6 = reinterpret<f64>(0x3DE5D93A5ACFD57C); //  1.58969099521155010221e-10\n\n  var z = x * x;\n  var w = z * z;\n  var r = S2 + z * (S3 + z * S4) + z * w * (S5 + z * S6);\n  var v = z * x;\n  if (!iy) {\n    return x + v * (S1 + z * r);\n  } else {\n    return x - ((z * (0.5 * y - v * r) - y) - v * S1);\n  }\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction cos_kern(x: f64, y: f64): f64 { // see: musl/tree/src/math/__cos.c\n  const C1 = reinterpret<f64>(0x3FA555555555554C); //  4.16666666666666019037e-02\n  const C2 = reinterpret<f64>(0xBF56C16C16C15177); // -1.38888888888741095749e-03\n  const C3 = reinterpret<f64>(0x3EFA01A019CB1590); //  2.48015872894767294178e-05\n  const C4 = reinterpret<f64>(0xBE927E4F809C52AD); // -2.75573143513906633035e-07\n  const C5 = reinterpret<f64>(0x3E21EE9EBDB4B1C4); //  2.08757232129817482790e-09\n  const C6 = reinterpret<f64>(0xBDA8FAE9BE8838D4); // -1.13596475577881948265e-11\n\n  var z = x * x;\n  var w = z * z;\n  var r = z * (C1 + z * (C2 + z * C3)) + w * w * (C4 + z * (C5 + z * C6));\n  var hz = 0.5 * z;\n  w = 1.0 - hz;\n  return w + (((1.0 - w) - hz) + (z * r - x * y));\n}\n\n/** @internal */\nfunction tan_kern(x: f64, y: f64, iy: i32): f64 { // see: src/lib/msun/src/k_tan.c\n  const T0  = reinterpret<f64>(0x3FD5555555555563); //  3.33333333333334091986e-01\n  const T1  = reinterpret<f64>(0x3FC111111110FE7A); //  1.33333333333201242699e-01\n  const T2  = reinterpret<f64>(0x3FABA1BA1BB341FE); //  5.39682539762260521377e-02\n  const T3  = reinterpret<f64>(0x3F9664F48406D637); //  2.18694882948595424599e-02\n  const T4  = reinterpret<f64>(0x3F8226E3E96E8493); //  8.86323982359930005737e-03\n  const T5  = reinterpret<f64>(0x3F6D6D22C9560328); //  3.59207910759131235356e-03\n  const T6  = reinterpret<f64>(0x3F57DBC8FEE08315); //  1.45620945432529025516e-03\n  const T7  = reinterpret<f64>(0x3F4344D8F2F26501); //  5.88041240820264096874e-04\n  const T8  = reinterpret<f64>(0x3F3026F71A8D1068); //  2.46463134818469906812e-04\n  const T9  = reinterpret<f64>(0x3F147E88A03792A6); //  7.81794442939557092300e-05\n  const T10 = reinterpret<f64>(0x3F12B80F32F0A7E9); //  7.14072491382608190305e-05\n  const T11 = reinterpret<f64>(0xBEF375CBDB605373); // -1.85586374855275456654e-05\n  const T12 = reinterpret<f64>(0x3EFB2A7074BF7AD4); //  2.59073051863633712884e-05\n\n  const one    = reinterpret<f64>(0x3FF0000000000000); // 1.00000000000000000000e+00\n  const pio4   = reinterpret<f64>(0x3FE921FB54442D18); // 7.85398163397448278999e-01\n  const pio4lo = reinterpret<f64>(0x3C81A62633145C07); // 3.06161699786838301793e-17\n\n  var z: f64, r: f64, v: f64, w: f64, s: f64;\n  var hx = <i32>(reinterpret<u64>(x) >> 32); /* high word of x */\n  var ix = hx & 0x7FFFFFFF; /* high word of |x| */\n  var big = ix >= 0x3FE59428;\n  if (big) { /* |x| >= 0.6744 */\n    if (hx < 0) { x = -x, y = -y; }\n    z = pio4 - x;\n    w = pio4lo - y;\n    x = z + w;\n    y = 0.0;\n  }\n  z = x * x;\n  w = z * z;\n  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));\n  v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));\n  s = z * x;\n  r = y + z * (s * (r + v) + y);\n  r += T0 * s;\n  w = x + r;\n  if (big) {\n    v = iy;\n    return (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));\n  }\n  if (iy == 1) return w;\n  var a: f64, t: f64;\n  z = w;\n  z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF00000000);\n  v = r - (z - x);  /* z + v = r + x */\n  t = a = -one / w; /* a = -1.0 / w */\n  t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n  s = one + t * z;\n  return t + a * (s + t * v);\n}\n\n/** @internal */\nfunction dtoi32(x: f64): i32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    const inv32 = 1.0 / 4294967296;\n    return <i32><i64>(x - 4294967296 * floor(x * inv32));\n  } else {\n    let result = 0;\n    let u = reinterpret<u64>(x);\n    let e = (u >> 52) & 0x7FF;\n    if (e <= 1023 + 30) {\n      result = <i32>x;\n    } else if (e <= 1023 + 30 + 53) {\n      let v = (u & ((<u64>1 << 52) - 1)) | (<u64>1 << 52);\n      v = v << e - 1023 - 52 + 32;\n      result = <i32>(v >> 32);\n      result = select<i32>(-result, result, u >> 63);\n    }\n    return result;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy\nvar random_seeded = false;\n\n// @ts-ignore: decorator\n@lazy\nvar random_state0_64: u64;\n\n// @ts-ignore: decorator\n@lazy\nvar random_state1_64: u64;\n\n// @ts-ignore: decorator\n@lazy\nvar random_state0_32: u32;\n\n// @ts-ignore: decorator\n@lazy\nvar random_state1_32: u32;\n\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\n  h *= 0xFF51AFD7ED558CCD;\n  h ^= h >> 33;\n  h *= 0xC4CEB9FE1A85EC53;\n  h ^= h >> 33;\n  return h;\n}\n\nfunction splitMix32(h: u32): u32 {\n  h += 0x6D2B79F5;\n  h  = (h ^ (h >> 15)) * (h | 1);\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\n  return h ^ (h >> 14);\n}\n\nexport namespace NativeMath {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_sin: f64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_cos: f64 = 0;\n\n  // @ts-ignore: decorator\n  @inline export function abs(x: f64): f64 {\n    return builtin_abs<f64>(x);\n  }\n\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) {\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\n    }\n    var s: f64, w: f64, z: f64;\n    if (hx >> 31) {\n      // z = (1.0 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f64>(z);\n      w = R(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1.0 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f64>(z);\n    var df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n    var c = (z - df * df) / (s + df);\n    w = R(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\n    var e = reinterpret<u64>(x) >> 52 & 0x7FF;\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\n      return x + x * R(x * x);\n    }\n    // var z = (1.0 - builtin_abs<f64>(x)) * 0.5;\n    var z = 0.5 - builtin_abs<f64>(x) * 0.5;\n    var s = builtin_sqrt<f64>(z);\n    var r = R(z);\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\n    else {\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n      let c = (z - f * f) / (s + f);\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\n    }\n    if (hx >> 31) return -x;\n    return x;\n  }\n\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\n    var u = reinterpret<u64>(x);\n    var e = u >> 52 & 0x7FF;\n    var y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\n    if (e >= 0x3FF + 26) y = log(y) + c;\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var ix = <u32>(reinterpret<u64>(x) >> 32);\n    var sx = x;\n    ix &= 0x7FFFFFFF;\n    var z: f64;\n    if (ix >= 0x44100000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign<f64>(z, sx);\n    }\n    var id: i32;\n    if (ix < 0x3FDC0000) {\n      if (ix < 0x3E400000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f64>(x);\n      if (ix < 0x3FF30000) {\n        if (ix < 0x3FE60000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x40038000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    var w = z * z;\n    var s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\n    var s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\n    var s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign<f64>(z, sx);\n  }\n\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\n    var u = reinterpret<u64>(x);\n    var e = u >> 52 & 0x7FF;\n    var y = builtin_abs(x);\n    if (e < 0x3FF - 1) {\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\n    } else {\n      y = 0.5 * log1p(2 * (y / (1 - y)));\n    }\n    return builtin_copysign<f64>(y, x);\n  }\n\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\n    if (isNaN(x) || isNaN(y)) return x + y;\n    var u = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var lx = <u32>u;\n    u = reinterpret<u64>(y);\n    var iy = <u32>(u >> 32);\n    var ly = <u32>u;\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\n    var m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\n    ix = ix & 0x7FFFFFFF;\n    iy = iy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  PI;\n        case 3: return -PI;\n      }\n    }\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\n    if (ix == 0x7FF00000) {\n      if (iy == 0x7FF00000) {\n        let t = m & 2 ? 3 * PI / 4 : PI / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t = m & 2 ? PI : 0;\n        return m & 1 ? -t : t;\n      }\n    }\n    var z: f64;\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\n    else z = atan(builtin_abs<f64>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return PI - (z - pi_lo);\n      case 3: return (z - pi_lo) - PI;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\n    const\n      B1     = <u32>715094163,\n      B2     = <u32>696219795,\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\n      Ox1p54 = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32) & 0x7FFFFFFF;\n    if (hx >= 0x7FF00000) return x + x;\n    if (hx < 0x00100000) {\n      u = reinterpret<u64>(x * Ox1p54);\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\n      if (hx == 0) return x;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 1 << 63;\n    u |= <u64>hx << 32;\n    var t = reinterpret<f64>(u);\n    var r = (t * t) * (t / x);\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\n    var s = t * t;\n    r = x / s;\n    r = (r - t) / (2 * t + r);\n    t = t + t * r;\n    return t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f64): f64 {\n    return builtin_ceil<f64>(x);\n  }\n\n  export function clz32(x: f64): f64 {\n    if (!isFinite(x)) return 32;\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    return builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f64): f64 { // see: musl/src/math/cos.c\n    var u  = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var sign = ix >> 31;\n\n    ix &= 0x7FFFFFFF;\n\n    /* |x| ~< pi/4 */\n    if (ix <= 0x3FE921FB) {\n      if (ix < 0x3E46A09E) {  /* |x| < 2**-27 * sqrt(2) */\n        return 1.0;\n      }\n      return cos_kern(x, 0);\n    }\n\n    /* sin(Inf or NaN) is NaN */\n    if (ix >= 0x7FF00000) return x - x;\n\n    /* argument reduction needed */\n    var n  = rempio2(x, u, sign);\n    var y0 = rempio2_y0;\n    var y1 = rempio2_y1;\n\n    x = n & 1 ? sin_kern(y0, y1, 1) : cos_kern(y0, y1);\n    return (n + 1) & 2 ? -x : x;\n  }\n\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\n    var u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    x = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    if (w < 0x3FE62E42) {\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\n      t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (w < 0x40862E42) {\n      t = exp(x);\n      return 0.5 * (t + 1 / t);\n    }\n    t = expo2(x);\n    return t;\n  }\n\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n      P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n      P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n      P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n      P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n      overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\n      underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000);\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var sign_ = <i32>(hx >> 31);\n    hx &= 0x7FFFFFFF;\n    if (hx >= 0x4086232B) {\n      if (isNaN(x)) return x;\n      if (x > overflow)  return x * Ox1p1023;\n      if (x < underflow) return 0;\n    }\n    var hi: f64, lo: f64 = 0;\n    var k = 0;\n    if (hx > 0x3FD62E42) {\n      if (hx >= 0x3FF0A2B2) {\n        k = <i32>(invln2 * x + builtin_copysign<f64>(0.5, x));\n      } else {\n        k = 1 - (sign_ << 1);\n      }\n      hi = x - k * ln2hi;\n      lo = k * ln2lo;\n      x = hi - lo;\n    } else if (hx > 0x3E300000) {\n      hi = x;\n    } else return 1.0 + x;\n    var xs = x * x;\n    // var c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\n    var xq = xs * xs;\n    var c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\n    var y = 1.0 + (x * c / (2 - c) - lo + hi);\n    if (k == 0) return y;\n    return scalbn(y, k);\n  }\n\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32 & 0x7FFFFFFF);\n    var k = 0, sign_ = <i32>(u >> 63);\n    if (hx >= 0x4043687A) {\n      if (isNaN(x)) return x;\n      if (sign_) return -1;\n      if (x > o_threshold) return x * Ox1p1023;\n    }\n    var c = 0.0, t: f64;\n    if (hx > 0x3FD62E42) {\n      k = select<i32>(\n        1 - (sign_ << 1),\n        <i32>(invln2 * x + builtin_copysign<f64>(0.5, x)),\n        hx < 0x3FF0A2B2\n      );\n      t = <f64>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x3C900000) return x;\n    var hfx = 0.5 * x;\n    var hxs = x * hfx;\n    // var r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\n    var hxq = hxs * hxs;\n    var r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\n    t = 3.0 - r1 * hfx;\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x3FF + k) << 52;\n    var twopk = reinterpret<f64>(u);\n    var y: f64;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x3FF - k) << 52;\n    y = reinterpret<f64>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f64): f64 {\n    return builtin_floor<f64>(x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f64): f64 {\n    return <f32>x;\n  }\n\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\n    const\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    ux &= 0x7FFFFFFFFFFFFFFF;\n    uy &= 0x7FFFFFFFFFFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    var ex = <i32>(ux >> 52);\n    var ey = <i32>(uy >> 52);\n    y = reinterpret<f64>(uy);\n    if (ey == 0x7FF) return y;\n    x = reinterpret<f64>(ux);\n    if (ex == 0x7FF || uy == 0) return x;\n    if (ex - ey > 64) return x + y;\n    var z = 1.0;\n    if (ex > 0x3FF + 510) {\n      z  = Ox1p700;\n      x *= Ox1p_700;\n      y *= Ox1p_700;\n    } else if (ey < 0x3FF - 450) {\n      z  = Ox1p_700;\n      x *= Ox1p700;\n      y *= Ox1p700;\n    }\n    var c = x * SPLIT;\n    var h = x - c + c;\n    var l = x - h;\n    var hx = x * x;\n    var lx = h * h - hx + (2 * h + l) * l;\n    c = y * SPLIT;\n    h = y - c + c;\n    l = y - h;\n    var hy = y * y;\n    var ly = h * h - hy + (2 * h + l) * l;\n    return z * builtin_sqrt(ly + lx + hy + hx);\n  }\n\n  export function imul(x: f64, y: f64): f64 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return dtoi32(x) * dtoi32(y);\n  }\n\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54 = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 0;\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (hx >> 31)    return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = <u32>(u >> 32);\n    } else if (hx >= 0x7FF00000) return x;\n      else if (hx == 0x3FF00000 && u << 32 == 0) return 0;\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += (<i32>hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    var f = x - 1.0;\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var dk = <f64>k;\n    return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54    = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 0;\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (hx >> 31) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = <u32>(u >> 32);\n    } else if (hx >= 0x7FF00000) return x;\n      else if (hx == 0x3FF00000 && u << 32 == 0) return 0;\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += <i32>(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    var f = x - 1.0;\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var val_hi = hi * ivln10hi;\n    var dk = <f64>k;\n    var y = dk * log10_2hi;\n    var val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    return val_lo + w;\n  }\n\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 1;\n    var c = 0.0, f = 0.0;\n    if (hx < 0x3FDA827A || <bool>(hx >> 31)) {\n      if (hx >= 0xBFF00000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (hx << 1 < 0x3CA00000 << 1) return x;\n      if (hx <= 0xBFD2BEC4) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (hx >= 0x7FF00000) return x;\n    if (k) {\n      u = reinterpret<u64>(1 + x);\n      let hu = <u32>(u >> 32);\n      hu += 0x3FF00000 - 0x3FE6A09E;\n      k = <i32>(hu >> 20) - 0x3FF;\n      if (k < 54) {\n        let uf = reinterpret<f64>(u);\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\n      f = reinterpret<f64>(u) - 1;\n    }\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var dk = <f64>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\n      ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\n      Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54  = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 0;\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (hx >> 31) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = <u32>(u >> 32);\n    } else if (hx >= 0x7FF00000) return x;\n      else if (hx == 0x3FF00000 && u << 32 == 0) return 0;\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += <i32>(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    var f = x - 1.0;\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var val_hi = hi * ivln2hi;\n    var val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\n    var y = <f64>k;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    val_hi = w;\n    return val_lo + val_hi;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f64, value2: f64): f64 {\n    return builtin_max<f64>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f64, value2: f64): f64 {\n    return builtin_min<f64>(value1, value2);\n  }\n\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\n    const\n      dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\n      dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\n      two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\n      huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\n      tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\n      L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\n      L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\n      L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\n      L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\n      L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\n      L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\n      P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n      P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n      P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n      P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n      P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n      lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\n      lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\n      lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\n      ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\n      cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\n      cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\n      cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\n      ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\n      ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\n      inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\n    var u_ = reinterpret<u64>(x);\n    var hx = <i32>(u_ >> 32);\n    var lx = <u32>u_;\n    u_ = reinterpret<u64>(y);\n    var hy = <i32>(u_ >> 32);\n    var ly = <u32>u_;\n    var ix = hx & 0x7FFFFFFF;\n    var iy = hy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\n    // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n    if ( // NaN if either arg is NaN\n      ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\n      iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\n    ) return x + y;\n    var yisint = 0, k: i32;\n    if (hx < 0) {\n      if (iy >= 0x43400000) yisint = 2;\n      else if (iy >= 0x3FF00000) {\n        k = (iy >> 20) - 0x3FF;\n        let kcond = k > 20;\n        let offset = select<i32>(52, 20, kcond) - k;\n        let Ly = select<i32>(ly, iy, kcond);\n        let jj = Ly >> offset;\n        if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\n      }\n    }\n    if (ly == 0) {\n      if (iy == 0x7FF00000) { // y is +-inf\n        if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n        else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n        else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n      }\n      if (iy == 0x3FF00000) {\n        if (hy >= 0) return x;\n        return 1 / x;\n      }\n      if (hy == 0x40000000) return x * x;\n      if (hy == 0x3FE00000) {\n        if (hx >= 0) return builtin_sqrt(x);\n      }\n    }\n    var ax = builtin_abs<f64>(x), z: f64;\n    if (lx == 0) {\n      if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {\n        z = ax;\n        if (hy < 0) z = 1.0 / z;\n        if (hx < 0) {\n          if (((ix - 0x3FF00000) | yisint) == 0) {\n            let d = z - z;\n            z = d / d;\n          } else if (yisint == 1) z = -z;\n        }\n        return z;\n      }\n    }\n    var s = 1.0;\n    if (hx < 0) {\n      if (yisint == 0) {\n        let d = x - x;\n        return d / d;\n      }\n      if (yisint == 1) s = -1.0;\n    }\n    var t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\n    var j: i32, n: i32;\n    if (iy > 0x41E00000) {\n      if (iy > 0x43F00000) {\n        if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\n        if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\n      }\n      if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\n      if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\n      t = ax - 1.0;\n      w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\n      u = ivln2_h * t;\n      v = t * ivln2_l - w * ivln2;\n      t1 = u + v;\n      t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n      t2 = v - (t1 - u);\n    } else {\n      let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\n      n = 0;\n      if (ix < 0x00100000) {\n        ax *= two53;\n        n -= 53;\n        ix = <u32>(reinterpret<u64>(ax) >> 32);\n      }\n      n += (ix >> 20) - 0x3FF;\n      j = ix & 0x000FFFFF;\n      ix = j | 0x3FF00000;\n      if (j <= 0x3988E) k = 0;\n      else if (j < 0xBB67A) k = 1;\n      else {\n        k = 0;\n        n += 1;\n        ix -= 0x00100000;\n      }\n      ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\n      let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\n      u = ax - bp;\n      v = 1.0 / (ax + bp);\n      ss = u * v;\n      s_h = ss;\n      s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\n      t_h = reinterpret<f64>(<u64>(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\n      t_l = ax - (t_h - bp);\n      s_l = v * ((u - s_h * t_h) - s_h * t_l);\n      s2 = ss * ss;\n      r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n      r += s_l * (s_h + ss);\n      s2 = s_h * s_h;\n      t_h = 3.0 + s2 + r;\n      t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\n      t_l = r - ((t_h - 3.0) - s2);\n      u = s_h * t_h;\n      v = s_l * t_h + t_l * ss;\n      p_h = u + v;\n      p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\n      p_l = v - (p_h - u);\n      let z_h = cp_h * p_h;\n      let dp_l = select<f64>(dp_l1, 0.0, k);\n      let z_l = cp_l * p_h + p_l * cp + dp_l;\n      t = <f64>n;\n      let dp_h = select<f64>(dp_h1, 0.0, k);\n      t1 = ((z_h + z_l) + dp_h) + t;\n      t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n      t2 = z_l - (((t1 - t) - dp_h) - z_h);\n    }\n    var y1 = y;\n    y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\n    p_l = (y - y1) * t1 + y * t2;\n    p_h = y1 * t1;\n    z = p_l + p_h;\n    u_ = reinterpret<u64>(z);\n    j = <u32>(u_ >> 32);\n    var i = <i32>u_;\n    if (j >= 0x40900000) {\n      if (((j - 0x40900000) | i) != 0) return s * huge * huge;\n      if (p_l + ovt > z - p_h) return s * huge * huge;\n    } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\n      if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\n      if (p_l <= z - p_h) return s * tiny * tiny;\n    }\n    i = j & 0x7FFFFFFF;\n    k = (i >> 20) - 0x3FF;\n    n = 0;\n    if (i > 0x3FE00000) {\n      n = j + (0x00100000 >> (k + 1));\n      k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\n      t = 0.0;\n      t = reinterpret<f64>(<u64>(n & ~(0x000FFFFF >> k)) << 32);\n      n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\n      if (j < 0) n = -n;\n      p_h -= t;\n    }\n    t = p_l + p_h;\n    t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n    u = t * lg2_h;\n    v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n    z = u + v;\n    w = v - (z - u);\n    t = z * z;\n    t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n    r = (z * t1) / (t1 - 2.0) - (w + z * w);\n    z = 1.0 - (r - z);\n    j = <u32>(reinterpret<u64>(z) >> 32);\n    j += n << 20;\n    if ((j >> 20) <= 0) z = scalbn(z, n);\n    else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\n    return s * z;\n  }\n\n  export function seedRandom(value: i64): void {\n    random_seeded = true;\n    random_state0_64 = murmurHash3(value);\n    random_state1_64 = murmurHash3(~random_state0_64);\n    random_state0_32 = splitMix32(<u32>value);\n    random_state1_32 = splitMix32(random_state0_32);\n    assert(\n      random_state0_64 != 0 && random_state1_64 != 0 &&\n      random_state0_32 != 0 && random_state1_32 != 0\n    );\n  }\n\n  export function random(): f64 { // see: v8/src/base/utils/random-number-generator.cc\n    if (!random_seeded) throw new Error(\"PRNG must be seeded.\");\n    var s1 = random_state0_64;\n    var s0 = random_state1_64;\n    random_state0_64 = s0;\n    s1 ^= s1 << 23;\n    s1 ^= s1 >> 17;\n    s1 ^= s0;\n    s1 ^= s0 >> 26;\n    random_state1_64 = s1;\n    var r = (s0 >> 12) | 0x3FF0000000000000;\n    return reinterpret<f64>(r) - 1;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function round(x: f64): f64 {\n    return builtin_copysign<f64>(builtin_floor<f64>(x + 0.5), x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sign(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_abs(x) > 0 ? builtin_copysign<f64>(1, x) : x;\n    } else {\n      return x > 0 ? 1 : x < 0 ? -1 : x;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f64): bool {\n    // In ECMAScript all NaN values are indistinguishable from each other\n    // so we need handle NaN and negative NaN in similar way\n    return <bool>(<i32>(reinterpret<u64>(x) >>> 63) & i32(x == x));\n  }\n\n  export function sin(x: f64): f64 { // see: musl/src/math/sin.c\n    var u  = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var sign = ix >> 31;\n\n    ix &= 0x7FFFFFFF;\n\n    /* |x| ~< pi/4 */\n    if (ix <= 0x3FE921FB) {\n      if (ix < 0x3E500000) { /* |x| < 2**-26 */\n        return x;\n      }\n      return sin_kern(x, 0.0, 0);\n    }\n\n    /* sin(Inf or NaN) is NaN */\n    if (ix >= 0x7FF00000) return x - x;\n\n    /* argument reduction needed */\n    var n  = rempio2(x, u, sign);\n    var y0 = rempio2_y0;\n    var y1 = rempio2_y1;\n\n    x = n & 1 ? cos_kern(y0, y1) : sin_kern(y0, y1, 1);\n    return n & 2 ? -x : x;\n  }\n\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\n    var u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\n    var absx = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    var h = builtin_copysign(0.5, x);\n    if (w < 0x40862E42) {\n      t = expm1(absx);\n      if (w < 0x3FF00000) {\n        if (w < 0x3FF00000 - (26 << 20)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    t = 2 * h * expo2(absx);\n    return t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f64): f64 {\n    return builtin_sqrt<f64>(x);\n  }\n\n  export function tan(x: f64): f64 { // see: musl/src/math/tan.c\n    var u = reinterpret<u64>(x);\n    var ix = <i32>(u >> 32);\n    var sign = ix >>> 31;\n\n    ix &= 0x7FFFFFFF;\n\n    /* |x| ~< pi/4 */\n    if (ix <= 0x3FE921FB) {\n      if (ix < 0x3E400000) { /* |x| < 2**-27 */\n        return x;\n      }\n      return tan_kern(x, 0.0, 1);\n    }\n\n    /* tan(Inf or NaN) is NaN */\n    if (ix >= 0x7FF00000) return x - x;\n\n    var n = rempio2(x, u, sign);\n    return tan_kern(rempio2_y0, rempio2_y1, 1 - ((n & 1) << 1));\n  }\n\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\n    var u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    var y = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    if (w > 0x3FE193EA) {\n      if (w > 0x40340000) {\n        t = 1 - 0 / y;\n      } else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (w > 0x3FD058AE) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (w >= 0x00100000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f64>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f64): f64 {\n    return builtin_trunc<f64>(x);\n  }\n\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\n    const\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\n    var y = x;\n    if (n > 1023) {\n      y *= Ox1p1023;\n      n -= 1023;\n      if (n > 1023) {\n        y *= Ox1p1023;\n        n = builtin_min<i32>(n - 1023, 1023);\n      }\n    } else if (n < -1022) {\n      /* make sure final n < -53 to avoid double\n       rounding in the subnormal range */\n      y *= Ox1p_1022 * Ox1p53;\n      n += 1022 - 53;\n      if (n < -1022) {\n        y *= Ox1p_1022 * Ox1p53;\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\n      }\n    }\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\n  }\n\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    var ex = <i64>(ux >> 52 & 0x7FF);\n    var ey = <i64>(uy >> 52 & 0x7FF);\n    var sx = ux >> 63;\n    var uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    var ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      if (ux1 == uy1) return 0 * x;\n      return x;\n    }\n    if (!ex) {\n      ex -= builtin_clz<i64>(ux << 12);\n      ux <<= -ex + 1;\n    } else {\n      ux &= <u64>-1 >> 12;\n      ux |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u64>-1 >> 12;\n      uy |= 1 << 52;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 52); ux <<= 1) --ex;\n    var shift = builtin_clz<i64>(ux << 11);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 52;\n      ux |= ex << 52;\n    } else {\n      ux >>= -ex + 1;\n    }\n    ux |= sx << 63;\n    return reinterpret<f64>(ux);\n  }\n\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    var ex = <i64>(ux >> 52 & 0x7FF);\n    var ey = <i64>(uy >> 52 & 0x7FF);\n    var sx = <i32>(ux >> 63);\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    if (ux << 1 == 0) return x;\n    var uxi = ux;\n    if (!ex) {\n      ex -= builtin_clz<i64>(uxi << 12);\n      uxi <<= -ex + 1;\n    } else {\n      uxi &= <u64>-1 >> 12;\n      uxi |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u64>-1 >> 12;\n      uy |= 1 << 52;\n    }\n    var q: u32 = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -60;\n      else {\n        let shift = builtin_clz<i64>(uxi << 11);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n  // end:\n    if (ex > 0) {\n      uxi -= 1 << 52;\n      uxi |= ex << 52;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f64>(uxi);\n    y = builtin_abs<f64>(y);\n    var x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // ++q;\n    }\n    return sx ? -x : x;\n  }\n\n  export function sincos(x: f64): void { // see: musl/tree/src/math/sincos.c\n    var u = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3FE921FB) { /* |x| ~<= π/4 */\n      if (ix < 0x3E46A09E) { /* if |x| < 2**-27 * sqrt(2) */\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kern(x, 0, 0);\n      sincos_cos = cos_kern(x, 0);\n      return;\n    }\n    /* sin(Inf or NaN) is NaN */\n    if (ix >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    /* general argument reduction needed */\n    var n = rempio2(x, u, sign);\n    var y0 = rempio2_y0;\n    var y1 = rempio2_y1;\n    var s = sin_kern(y0, y1, 1);\n    var c = cos_kern(y0, y1);\n    var sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy\nvar rempio2f_y: f64;\n\n// @ts-ignore: decorator\n@lazy\nconst PIO2F_TABLE: u64[] = [\n  0xA2F9836E4E441529,\n  0xFC2757D1F534DDC0,\n  0xDB6295993C439041,\n  0xFE5163ABDEBBC561\n];\n\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\n  var p = z * (pS0 + z * (pS1 + z * pS2));\n  var q: f32 = 1 + z * qS1;\n  return p / q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction expo2f(x: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                                // see: musl/src/math/__expo2f.c\n    k    = <u32>235,\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\n  var scale = reinterpret<f32>(<u32>(0x7F + (k >> 1)) << 23);\n  return NativeMathf.exp(x - kln2) * scale * scale;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pio2f_large_quot(x: f32, u: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const coeff = reinterpret<f64>(0x3BF921FB54442D18); // π * 0x1p-65 = 8.51530395021638647334e-20\n  const bits = PIO2F_TABLE.dataStart;\n\n  var offset = (u >> 23) - 152;\n  var shift  = <u64>(offset & 63);\n  var tblPtr = bits + (offset >> 6 << 3);\n\n  var b0 = load<u64>(tblPtr, 0 << 3);\n  var b1 = load<u64>(tblPtr, 1 << 3);\n  var lo: u64;\n\n  if (shift > 32) {\n    let b2 = load<u64>(tblPtr, 2 << 3);\n    lo  = b2 >> (96 - shift);\n    lo |= b1 << (shift - 32);\n  } else {\n    lo = b1 >> (32 - shift);\n  }\n\n  var hi = (b1 >> (64 - shift)) | (b0 << shift);\n  var mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;\n  var product = mantissa * hi + (mantissa * lo >> 32);\n  var r: i64 = product << 2;\n  var q = <i32>((product >> 62) + (r >>> 63));\n  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;\n  return q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction rempio2f(x: f32, u: u32, sign: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const pi2hi = reinterpret<f64>(0x3FF921FB50000000); // 1.57079631090164184570\n  const pi2lo = reinterpret<f64>(0x3E5110B4611A6263); // 1.58932547735281966916e-8\n  const _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  if (u < 0x4DC90FDB) { /* π * 0x1p28 */\n    let q = nearest(x * _2_pi);\n    rempio2f_y = x - q * pi2hi - q * pi2lo;\n    return <i32>q;\n  }\n\n  var q = pio2f_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n/* |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]). */\n// @ts-ignore: decorator\n@inline\nfunction sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c\n  const S1 = reinterpret<f64>(0xBFC5555554CBAC77); // -0x15555554cbac77.0p-55\n  const S2 = reinterpret<f64>(0x3F811110896EFBB2); //  0x111110896efbb2.0p-59\n  const S3 = reinterpret<f64>(0xBF2A00F9E2CAE774); // -0x1a00f9e2cae774.0p-65\n  const S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71\n\n  var z = x * x;\n  var w = z * z;\n  var r = S3 + z * S4;\n  var s = z * x;\n  return <f32>((x + s * (S1 + z * S2)) + s * w * r);\n}\n\n/* |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]). */\n// @ts-ignore: decorator\n@inline\nfunction cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c\n  const C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81); // -0x1ffffffd0c5e81.0p-54\n  const C1 = reinterpret<f64>(0x3FA55553E1053A42); //  0x155553e1053a42.0p-57\n  const C2 = reinterpret<f64>(0xBF56C087E80F1E27); // -0x16c087e80f1e27.0p-62\n  const C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68\n\n  var z = x * x;\n  var w = z * z;\n  var r = C2 + z * C3;\n  return <f32>(((1 + z * C0) + w * C1) + (w * z) * r);\n}\n\n/* |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]). */\n// @ts-ignore: decorator\n@inline\nfunction tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c\n\n  const T0 = reinterpret<f64>(0x3FD5554D3418C99F); /* 0x15554d3418c99f.0p-54 */\n  const T1 = reinterpret<f64>(0x3FC112FD38999F72); /* 0x1112fd38999f72.0p-55 */\n  const T2 = reinterpret<f64>(0x3FAB54C91D865AFE); /* 0x1b54c91d865afe.0p-57 */\n  const T3 = reinterpret<f64>(0x3F991DF3908C33CE); /* 0x191df3908c33ce.0p-58 */\n  const T4 = reinterpret<f64>(0x3F685DADFCECF44E); /* 0x185dadfcecf44e.0p-61 */\n  const T5 = reinterpret<f64>(0x3F8362B9BF971BCD); /* 0x1362b9bf971bcd.0p-59 */\n\n  var z = x * x;\n  var r = T4 + z * T5;\n  var t = T2 + z * T3;\n  var w = z * z;\n  var s = z * x;\n  var u = T0 + z * T1;\n\n  r = (x + s * u) + (s * w) * (t + w * r);\n  return <f32>(odd ? -1 / r : r);\n}\n\nexport namespace NativeMathf {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = <f32>NativeMath.E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = <f32>NativeMath.LN2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = <f32>NativeMath.LN10;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = <f32>NativeMath.LOG2E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = <f32>NativeMath.LOG10E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = <f32>NativeMath.PI;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = <f32>NativeMath.SQRT2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_sin: f32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_cos: f32 = 0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function abs(x: f32): f32 {\n    return builtin_abs<f32>(x);\n  }\n\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var hx = reinterpret<u32>(x);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3F800000) {\n      if (ix == 0x3F800000) {\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3F000000) {\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\n    }\n    var z: f32, w: f32, s: f32;\n    if (hx >> 31) {\n      // z = (1 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f32>(z);\n      w = Rf(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f32>(z);\n    hx = reinterpret<u32>(s);\n    var df = reinterpret<f32>(hx & 0xFFFFF000);\n    var c = (z - df * df) / (s + df);\n    w = Rf(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    var u = reinterpret<u32>(x);\n    var a = u & 0x7FFFFFFF;\n    if (a < 0x3F800000 + (1 << 23)) {\n      let xm1 = x - 1;\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\n    }\n    if (a < 0x3F800000 + (12 << 23)) return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var sx = x;\n    var hx = reinterpret<u32>(x) & 0x7FFFFFFF;\n    if (hx >= 0x3F800000) {\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (hx < 0x3F000000) {\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\n      return x + x * Rf(x * x);\n    }\n    // var z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\n    var z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\n    var s = builtin_sqrt<f64>(z); // sic\n    x = <f32>(pio2 - 2 * (s + s * Rf(z)));\n    return builtin_copysign(x, sx);\n  }\n\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    var y = reinterpret<f32>(u);\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var ix = reinterpret<u32>(x);\n    var sx = x;\n    ix &= 0x7FFFFFFF;\n    var z: f32;\n    if (ix >= 0x4C800000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign(z, sx);\n    }\n    var id: i32;\n    if (ix < 0x3EE00000) {\n      if (ix < 0x39800000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f32>(x);\n      if (ix < 0x3F980000) {\n        if (ix < 0x3F300000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x401C0000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    var w = z * z;\n    var s1 = z * (aT0 + w * (aT2 + w * aT4));\n    var s2 = w * (aT1 + w * aT3);\n    var s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign(z, sx);\n  }\n\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\n    var u = reinterpret<u32>(x);\n    var y = builtin_abs(x);\n    if (u < 0x3F800000 - (1 << 23)) {\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\n    const\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\n    if (isNaN(x) || isNaN(y)) return x + y;\n    var ix = reinterpret<u32>(x);\n    var iy = reinterpret<u32>(y);\n    if (ix == 0x3F800000) return atan(y);\n    var m = <u32>(((iy >> 31) & 1) | ((ix >> 30) & 2));\n    ix &= 0x7FFFFFFF;\n    iy &= 0x7FFFFFFF;\n    if (iy == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  pi;\n        case 3: return -pi;\n      }\n    }\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\n    if (ix == 0x7F800000) {\n      if (iy == 0x7F800000) {\n        let t: f32 = m & 2 ? 3 * pi / 4 : pi / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t: f32 = m & 2 ? pi : 0.0;\n        return m & 1 ? -t : t;\n      }\n    }\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\n    var z: f32;\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\n    else z = atan(builtin_abs<f32>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return pi - (z - pi_lo);\n      case 3: return (z - pi_lo) - pi;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\n    const\n      B1      = <u32>709958130,\n      B2      = <u32>642849266,\n      Ox1p24f = reinterpret<f32>(0x4B800000);\n    var u = reinterpret<u32>(x);\n    var hx = u & 0x7FFFFFFF;\n    if (hx >= 0x7F800000) return x + x;\n    if (hx < 0x00800000) {\n      if (hx == 0) return x;\n      u = reinterpret<u32>(x * Ox1p24f);\n      hx = u & 0x7FFFFFFF;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 0x80000000;\n    u |= hx;\n    var t = <f64>reinterpret<f32>(u);\n    var r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    return <f32>t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f32): f32 {\n    return builtin_ceil<f32>(x);\n  }\n\n  export function clz32(x: f32): f32 {\n    if (!isFinite(x)) return 32;\n    return <f32>builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c\n    const c1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // M_PI_2 * 1\n    const c2pio2 = reinterpret<f64>(0x400921FB54442D18); // M_PI_2 * 2\n    const c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // M_PI_2 * 3\n    const c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  /* |x| ~<= π/4 */\n      if (ix < 0x39800000) { /* |x| < 2**-12 */\n        /* raise inexact if x != 0 */\n        return 1;\n      }\n      return cos_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {  /* |x| ~<= 5π/4 */\n        if (ix > 0x4016CBE3) { /* |x|  ~> 3π/4 */\n          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);\n        } else {\n          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);\n        }\n      }\n      if (ix <= 0x40E231D5) {  /* |x| ~<= 9π/4 */\n        if (ix > 0x40AFEDDF) { /* |x|  ~> 7π/4 */\n          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);\n        } else {\n          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);\n        }\n      }\n    }\n\n    /* cos(Inf or NaN) is NaN */\n    if (ix >= 0x7F800000) return x - x;\n\n    /* general argument reduction needed */\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n\n    var t = n & 1 ? sin_kernf(y) : cos_kernf(y);\n    return (n + 1) & 2 ? -t : t;\n  }\n\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\n    var u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    x = reinterpret<f32>(u);\n    if (u < 0x3F317217) {\n      if (u < 0x3F800000 - (12 << 23)) return 1;\n      let t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (u < 0x42B17217) {\n      let t = exp(x);\n      // return 0.5 * (t + 1 / t);\n      return 0.5 * t + 0.5 / t;\n    }\n    return expo2f(x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f32): f32 {\n    return builtin_floor<f32>(x);\n  }\n\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\n      ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\n      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\n      P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\n      P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\n      Ox1p127f = reinterpret<f32>(0x7F000000);\n    var hx = reinterpret<u32>(x);\n    var sign_ = <i32>(hx >> 31);\n    hx &= 0x7FFFFFFF;\n    if (hx >= 0x42AEAC50) {\n      if (hx >= 0x42B17218) {\n        if (!sign_) return x * Ox1p127f;\n        else if (hx >= 0x42CFF1B5) return 0;\n      }\n    }\n    var hi: f32, lo: f32;\n    var k: i32;\n    if (hx > 0x3EB17218) {\n      if (hx > 0x3F851592) {\n        k = <i32>(invln2 * x + builtin_copysign<f32>(0.5, x));\n      } else {\n        k = 1 - (sign_ << 1);\n      }\n      hi = x - <f32>k * ln2hi;\n      lo = <f32>k * ln2lo;\n      x = hi - lo;\n    } else if (hx > 0x39000000) {\n      k = 0;\n      hi = x;\n      lo = 0;\n    } else {\n      return 1 + x;\n    }\n    var xx = x * x;\n    var c = x - xx * (P1 + xx * P2);\n    var y: f32 = 1 + (x * c / (2 - c) - lo + hi);\n    if (k == 0) return y;\n    return scalbn(y, k);\n  }\n\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f32>(0x42B17180), //  8.8721679688e+01f\n      ln2_hi      = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\n      ln2_lo      = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\n      invln2      = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\n      Q1          = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\n      Q2          = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\n      Ox1p127f    = reinterpret<f32>(0x7F000000);\n    var u = reinterpret<u32>(x);\n    var hx = u & 0x7FFFFFFF;\n    var sign_ = <i32>(u >> 31);\n    if (hx >= 0x4195B844) {\n      if (hx > 0x7F800000) return x;\n      if (sign_) return -1;\n      if (x > o_threshold) {\n        x *= Ox1p127f;\n        return x;\n      }\n    }\n    var c: f32 = 0.0, t: f32, k: i32;\n    if (hx > 0x3EB17218) {\n      k = select<i32>(\n        1 - (sign_ << 1),\n        <i32>(invln2 * x + builtin_copysign<f32>(0.5, x)),\n        hx < 0x3F851592\n      );\n      t = <f32>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x33000000) {\n      return x;\n    } else k = 0;\n    var hfx: f32 = 0.5 * x;\n    var hxs: f32 = x * hfx;\n    var r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\n    t  = 3.0 - r1 * hfx;\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e  = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x7F + k) << 23;\n    var twopk = reinterpret<f32>(u);\n    var y: f32;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 128) y = y * 2.0 * Ox1p127f;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x7F - k) << 23;\n    y = reinterpret<f32>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f32): f32 {\n    return x;\n  }\n\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\n    const\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\n      Ox1p_90f = reinterpret<f32>(0x12800000);\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    ux &= 0x7FFFFFFF;\n    uy &= 0x7FFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    x = reinterpret<f32>(ux);\n    y = reinterpret<f32>(uy);\n    if (uy == 0xFF << 23) return y;\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\n    var z: f32 = 1;\n    if (ux >= (0x7F + 60) << 23) {\n      z  = Ox1p90f;\n      x *= Ox1p_90f;\n      y *= Ox1p_90f;\n    } else if (uy < (0x7F - 60) << 23) {\n      z  = Ox1p_90f;\n      x *= Ox1p90f;\n      y *= Ox1p90f;\n    }\n    return z * builtin_sqrt<f32>(<f32>(<f64>x * x + <f64>y * y));\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function imul(x: f32, y: f32): f32 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return <f32>(dtoi32(x) * dtoi32(y));\n  }\n\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\n      ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\n      Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\n      Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\n      Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\n      Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\n      Ox1p25f = reinterpret<f32>(0x4C000000);\n    var u = reinterpret<u32>(x);\n    var k = 0;\n    if (u < 0x00800000 || <bool>(u >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (u >> 31) return (x - x) / 0;\n      k -= 25;\n      x *= Ox1p25f;\n      u = reinterpret<u32>(x);\n    } else if (u >= 0x7F800000) return x;\n      else if (u == 0x3F800000) return 0;\n    u += 0x3F800000 - 0x3F3504F3;\n    k += <u32>(<i32>u >> 23) - 0x7F;\n    u = (u & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(u);\n    var f = x - 1.0;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq = <f32>0.5 * f * f;\n    var dk = <f32>k;\n    return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f   = reinterpret<f32>(0x4C000000);\n    var ix = reinterpret<u32>(x);\n    var k = 0;\n    if (ix < 0x00800000 || <bool>(ix >> 31)) {\n      if (ix << 1 == 0) return -1 / (x * x);\n      if (ix >> 31) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ix = reinterpret<u32>(x);\n    } else if (ix >= 0x7F800000) return x;\n      else if (ix == 0x3F800000) return 0;\n    ix += 0x3F800000 - 0x3F3504F3;\n    k += <i32>(ix >> 23) - 0x7F;\n    ix = (ix & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ix);\n    var f = x - 1.0;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var hi = f - hfsq;\n    ix = reinterpret<u32>(hi);\n    ix &= 0xFFFFF000;\n    hi = reinterpret<f32>(ix);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var dk = <f32>k;\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\n  }\n\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\n    var ix = reinterpret<u32>(x);\n    var c: f32 = 0, f: f32 = 0;\n    var k: i32 = 1;\n    if (ix < 0x3ED413D0 || <bool>(ix >> 31)) {\n      if (ix >= 0xBF800000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (ix << 1 < 0x33800000 << 1) return x;\n      if (ix <= 0xBE95F619) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (ix >= 0x7F800000) return x;\n    if (k) {\n      let uf: f32 = 1 + x;\n      let iu = reinterpret<u32>(uf);\n      iu += 0x3F800000 - 0x3F3504F3;\n      k = <i32>(iu >> 23) - 0x7F;\n      if (k < 25) {\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\n      f = reinterpret<f32>(iu) - 1;\n    }\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var dk = <f32>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\n      ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\n      Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f = reinterpret<f32>(0x4C000000);\n    var ix = reinterpret<u32>(x);\n    var k: i32 = 0;\n    if (ix < 0x00800000 || <bool>(ix >> 31)) {\n      if (ix << 1 == 0) return -1 / (x * x);\n      if (ix >> 31) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ix = reinterpret<u32>(x);\n    } else if (ix >= 0x7F800000) return x;\n      else if (ix == 0x3F800000) return 0;\n    ix += 0x3F800000 - 0x3F3504F3;\n    k += <i32>(ix >> 23) - 0x7F;\n    ix = (ix & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ix);\n    var f = x - 1.0;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var hi = f - hfsq;\n    var u = reinterpret<u32>(hi);\n    u &= 0xFFFFF000;\n    hi = reinterpret<f32>(u);\n    var lo: f32 = f - hi - hfsq + s * (hfsq + r);\n    var dk = <f32>k;\n    return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f32, value2: f32): f32 {\n    return builtin_max<f32>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f32, value2: f32): f32 {\n    return builtin_min<f32>(value1, value2);\n  }\n\n  export function pow(x: f32, y: f32): f32 { // see: musl/src/math/powf.c and SUN COPYRIGHT NOTICE above\n    const\n      dp_h1   = reinterpret<f32>(0x3F15C000), //  5.84960938e-01f\n      dp_l1   = reinterpret<f32>(0x35D1CFDC), //  1.56322085e-06f\n      two24   = reinterpret<f32>(0x4B800000), //  16777216f\n      huge    = reinterpret<f32>(0x7149F2CA), //  1.0e+30f\n      tiny    = reinterpret<f32>(0x0DA24260), //  1.0e-30f\n      L1      = reinterpret<f32>(0x3F19999A), //  6.0000002384e-01f\n      L2      = reinterpret<f32>(0x3EDB6DB7), //  4.2857143283e-01f\n      L3      = reinterpret<f32>(0x3EAAAAAB), //  3.3333334327e-01f\n      L4      = reinterpret<f32>(0x3E8BA305), //  2.7272811532e-01f\n      L5      = reinterpret<f32>(0x3E6C3255), //  2.3066075146e-01f\n      L6      = reinterpret<f32>(0x3E53F142), //  2.0697501302e-01f\n      P1      = reinterpret<f32>(0x3E2AAAAB), //  1.6666667163e-01f\n      P2      = reinterpret<f32>(0xBB360B61), // -2.7777778450e-03f\n      P3      = reinterpret<f32>(0x388AB355), //  6.6137559770e-05f\n      P4      = reinterpret<f32>(0xB5DDEA0E), // -1.6533901999e-06f\n      P5      = reinterpret<f32>(0x3331BB4C), //  4.1381369442e-08f\n      lg2     = reinterpret<f32>(0x3F317218), //  6.9314718246e-01f\n      lg2_h   = reinterpret<f32>(0x3F317200), //  6.93145752e-01f\n      lg2_l   = reinterpret<f32>(0x35BFBE8C), //  1.42860654e-06f\n      ovt     = reinterpret<f32>(0x3338AA3C), //  4.2995665694e-08f\n      cp      = reinterpret<f32>(0x3F76384F), //  9.6179670095e-01\n      cp_h    = reinterpret<f32>(0x3F764000), //  9.6191406250e-01\n      cp_l    = reinterpret<f32>(0xB8F623C6), // -1.1736857402e-04\n      ivln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00\n      ivln2_h = reinterpret<f32>(0x3FB8AA00), //  1.4426879883e+00\n      ivln2_l = reinterpret<f32>(0x36ECA570), //  7.0526075433e-06\n      inv3    = reinterpret<f32>(0x3EAAAAAB);  // 0.333333333333\n    var hx = reinterpret<i32>(x);\n    var hy = reinterpret<i32>(y);\n    var ix = hx & 0x7FFFFFFF;\n    var iy = hy & 0x7FFFFFFF;\n    if (iy == 0) return 1.0; // x**0 = 1, even if x is NaN\n    // if (hx == 0x3F800000) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n    if (ix > 0x7F800000 || iy > 0x7F800000) return x + y; // NaN if either arg is NaN\n    var yisint  = 0, j: i32, k: i32;\n    if (hx < 0) {\n      if (iy >= 0x4B800000) yisint = 2;\n      else if (iy >= 0x3F800000) {\n        k = (iy >> 23) - 0x7F;\n        let ki = 23 - k;\n        j = iy >> ki;\n        if ((j << ki) == iy) yisint = 2 - (j & 1);\n      }\n    }\n    if (iy == 0x7F800000) { // y is +-inf\n      if (ix == 0x3F800000) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n      else if (ix > 0x3F800000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n      else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n    }\n    if (iy == 0x3F800000) return hy >= 0 ? x : 1.0 / x;\n    if (hy == 0x40000000) return x * x;\n    if (hy == 0x3F000000) {\n      if (hx >= 0) return builtin_sqrt<f32>(x);\n    }\n    var ax = builtin_abs<f32>(x);\n    var z: f32;\n    if (ix == 0x7F800000 || ix == 0 || ix == 0x3F800000) {\n      z = ax;\n      if (hy < 0) z = 1.0 / z;\n      if (hx < 0) {\n        if (((ix - 0x3F800000) | yisint) == 0) {\n          let d = z - z;\n          z = d / d;\n        }\n        else if (yisint == 1) z = -z;\n      }\n      return z;\n    }\n    var sn = <f32>1.0;\n    if (hx < 0) {\n      if (yisint == 0) {\n        let d = x - x;\n        return d / d;\n      }\n      if (yisint == 1) sn = -1.0;\n    }\n    var t1: f32, t2: f32, r: f32, s: f32, t: f32, u: f32, v: f32, w: f32, p_h: f32, p_l: f32;\n    var n: i32, is: i32;\n    if (iy > 0x4D000000) {\n      if (ix < 0x3F7FFFF8) return hy < 0 ? sn * huge * huge : sn * tiny * tiny;\n      if (ix > 0x3F800007) return hy > 0 ? sn * huge * huge : sn * tiny * tiny;\n      t = ax - 1;\n      w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\n      u = ivln2_h * t;\n      v = t * ivln2_l - w * ivln2;\n      t1 = u + v;\n      is = reinterpret<i32>(t1);\n      t1 = reinterpret<f32>(is & 0xFFFFF000);\n      t2 = v - (t1 - u);\n    } else {\n      let s2: f32, s_h: f32, s_l: f32, t_h: f32, t_l: f32;\n      n = 0;\n      if (ix < 0x00800000) {\n        ax *= two24;\n        n -= 24;\n        ix = reinterpret<i32>(ax);\n      }\n      n += (ix >> 23) - 0x7F;\n      j = ix & 0x007FFFFF;\n      ix = j | 0x3F800000;\n      if (j <= 0x1CC471) k = 0;\n      else if (j < 0x5DB3D7) k = 1;\n      else {\n        k = 0;\n        n += 1;\n        ix -= 0x00800000;\n      }\n      ax = reinterpret<f32>(ix);\n      let bp = select<f32>(1.5, 1.0, k); // k ? 1.5 : 1.0\n      u = ax - bp;\n      v = 1.0 / (ax + bp);\n      s = u * v;\n      s_h = s;\n      is = reinterpret<u32>(s_h);\n      s_h = reinterpret<f32>(is & 0xFFFFF000);\n      is = ((ix >> 1) & 0xFFFFF000) | 0x20000000;\n      t_h = reinterpret<f32>(is + 0x00400000 + (k << 21));\n      t_l = ax - (t_h - bp);\n      s_l = v * ((u - s_h * t_h) - s_h * t_l);\n      s2 = s * s;\n      r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n      r += s_l * (s_h + s);\n      s2 = s_h * s_h;\n      t_h = 3.0 + s2 + r;\n      is  = reinterpret<u32>(t_h);\n      t_h = reinterpret<f32>(is & 0xFFFFF000);\n      t_l = r - ((t_h - 3.0) - s2);\n      u = s_h * t_h;\n      v = s_l * t_h + t_l * s;\n      p_h = u + v;\n      is  = reinterpret<u32>(p_h);\n      p_h = reinterpret<f32>(is & 0xFFFFF000);\n      p_l = v - (p_h - u);\n      let z_h = cp_h * p_h;\n      let dp_l = select<f32>(dp_l1, 0.0, k);\n      let z_l = cp_l * p_h + p_l * cp + dp_l;\n      t = <f32>n;\n      let dp_h = select<f32>(dp_h1, 0.0, k);\n      t1 = (((z_h + z_l) + dp_h) + t);\n      is = reinterpret<u32>(t1);\n      t1 = reinterpret<f32>(is & 0xFFFFF000);\n      t2 = z_l - (((t1 - t) - dp_h) - z_h);\n    }\n    is = reinterpret<u32>(y);\n    var y1 = reinterpret<f32>(is & 0xFFFFF000);\n    p_l = (y - y1) * t1 + y * t2;\n    p_h = y1 * t1;\n    z = p_l + p_h;\n    j = reinterpret<u32>(z);\n    if (j > 0x43000000) {\n      return sn * huge * huge;\n    } else if (j == 0x43000000) {\n      if (p_l + ovt > z - p_h) return sn * huge * huge;\n    } else if ((j & 0x7FFFFFFF) > 0x43160000) {\n      return sn * tiny * tiny;\n    } else if (j == 0xC3160000) {\n      if (p_l <= z - p_h) return sn * tiny * tiny;\n    }\n    var i = j & 0x7FFFFFFF;\n    k = (i >> 23) - 0x7F;\n    n = 0;\n    if (i > 0x3F000000) {\n      n = j + (0x00800000 >> (k + 1));\n      k = ((n & 0x7FFFFFFF) >> 23) - 0x7F;\n      t = reinterpret<f32>(n & ~(0x007FFFFF >> k));\n      n = ((n & 0x007FFFFF) | 0x00800000) >> (23 - k);\n      if (j < 0) n = -n;\n      p_h -= t;\n    }\n    t = p_l + p_h;\n    is = reinterpret<u32>(t);\n    t = reinterpret<f32>(is & 0xFFFF8000);\n    u = t * lg2_h;\n    v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n    z = u + v;\n    w = v - (z - u);\n    t = z * z;\n    t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n    r = (z * t1) / (t1 - 2.0) - (w + z * w);\n    z = 1.0 - (r - z);\n    j = reinterpret<u32>(z);\n    j += n << 23;\n    if ((j >> 23) <= 0) z = scalbn(z, n);\n    else z = reinterpret<f32>(j);\n    return sn * z;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function seedRandom(value: i64): void {\n    NativeMath.seedRandom(value);\n  }\n\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n  export function random(): f32 {\n    if (!random_seeded) throw new Error(\"PRNG must be seeded.\");\n\n    var s0 = random_state0_32;\n    var s1 = random_state1_32;\n    var r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\n\n    s1 ^= s0;\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\n    random_state1_32 = rotl<u32>(s1, 13);\n\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function round(x: f32): f32 {\n    return builtin_copysign<f32>(builtin_floor<f32>(x + 0.5), x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sign(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_abs(x) > 0 ? builtin_copysign<f32>(1, x) : x;\n    } else {\n      return x > 0 ? 1 : x < 0 ? -1 : x;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f32): bool {\n    // @ts-ignore: type\n    return <bool>((reinterpret<u32>(x) >>> 31) & (x == x));\n  }\n\n  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c\n    const s1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // M_PI_2 * 1\n    const s2pio2 = reinterpret<f64>(0x400921FB54442D18); // M_PI_2 * 2\n    const s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // M_PI_2 * 3\n    const s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  /* |x| ~<= π/4 */\n      if (ix < 0x39800000) { /* |x| < 2**-12 */\n        return x;\n      }\n      return sin_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {   /* |x| ~<= 5π/4 */\n        if (ix <= 0x4016CBE3) { /* |x| ~<= 3π/4 */\n          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);\n        }\n        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));\n      }\n\n      if (ix <= 0x40E231D5) {   /* |x| ~<= 9π/4 */\n        if (ix <= 0x40AFEDDF) { /* |x| ~<= 7π/4 */\n          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);\n        }\n        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n      }\n    }\n\n    /* sin(Inf or NaN) is NaN */\n    if (ix >= 0x7F800000) return x - x;\n\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n\n    var t = n & 1 ? cos_kernf(y) : sin_kernf(y);\n    return n & 2 ? -t : t;\n  }\n\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    var absx = reinterpret<f32>(u);\n    var t: f32;\n    var h = builtin_copysign<f32>(0.5, x);\n    if (u < 0x42B17217) {\n      t = expm1(absx);\n      if (u < 0x3F800000) {\n        if (u < 0x3F800000 - (12 << 23)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    t = 2 * h * expo2f(absx);\n    return t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f32): f32 {\n    return builtin_sqrt<f32>(x);\n  }\n\n  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c\n    const t1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // 1 * M_PI_2\n    const t2pio2 = reinterpret<f64>(0x400921FB54442D18); // 2 * M_PI_2\n    const t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // 3 * M_PI_2\n    const t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  /* |x| ~<= π/4 */\n      if (ix < 0x39800000) { /* |x| < 2**-12 */\n        return x;\n      }\n      return tan_kernf(x, 0);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {   /* |x| ~<= 5π/4 */\n        if (ix <= 0x4016CBE3) { /* |x| ~<= 3π/4 */\n          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);\n        }\n      }\n      if (ix <= 0x40E231D5) {   /* |x| ~<= 9π/4 */\n        if (ix <= 0x40AFEDDF) { /* |x| ~<= 7π/4 */\n          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);\n        }\n      }\n    }\n\n    /* tan(Inf or NaN) is NaN */\n    if (ix >= 0x7F800000) return x - x;\n\n    /* argument reduction */\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n    return tan_kernf(y, n & 1);\n  }\n\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\n    var u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    var y = reinterpret<f32>(u);\n    var t: f32;\n    if (u > 0x3F0C9F54) {\n      if (u > 0x41200000) t = 1 + 0 / y;\n      else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (u > 0x3E82C578) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (u >= 0x00800000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f32>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f32): f32 {\n    return builtin_trunc<f32>(x);\n  }\n\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\n    const\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\n      Ox1p_126f = reinterpret<f32>(0x00800000);\n    var y = x;\n    if (n > 127) {\n      y *= Ox1p127f;\n      n -= 127;\n      if (n > 127) {\n        y *= Ox1p127f;\n        n = builtin_min<i32>(n - 127, 127);\n      }\n    } else if (n < -126) {\n      y *= Ox1p_126f * Ox1p24f;\n      n += 126 - 24;\n      if (n < -126) {\n        y *= Ox1p_126f * Ox1p24f;\n        n = builtin_max<i32>(n + 126 - 24, -126);\n      }\n    }\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\n  }\n\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    var ex = <i32>(ux >> 23 & 0xFF);\n    var ey = <i32>(uy >> 23 & 0xFF);\n    var sx = ux & 0x80000000;\n    var uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    var ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      if (ux1 == uy1) return 0 * x;\n      return x;\n    }\n    if (!ex) {\n      ex -= builtin_clz<u32>(ux << 9);\n      ux <<= -ex + 1;\n    } else {\n      ux &= <u32>-1 >> 9;\n      ux |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u32>-1 >> 9;\n      uy |= 1 << 23;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 23); ux <<= 1) --ex;\n    var shift = <i32>builtin_clz<u32>(ux << 8);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 23;\n      ux |= <u32>ex << 23;\n    } else {\n      ux >>= -ex + 1;\n    }\n    ux |= sx;\n    return reinterpret<f32>(ux);\n  }\n\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    var ex = <i32>(ux >> 23 & 0xFF);\n    var ey = <i32>(uy >> 23 & 0xFF);\n    var sx = <i32>(ux >> 31);\n    var uxi = ux;\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\n    if (ux << 1 == 0) return x;\n    if (!ex) {\n      ex -= builtin_clz<u32>(uxi << 9);\n      uxi <<= -ex + 1;\n    } else {\n      uxi &= <u32>-1 >> 9;\n      uxi |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u32>-1 >> 9;\n      uy |= 1 << 23;\n    }\n    var q = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -30;\n      else {\n        let shift = builtin_clz<i32>(uxi << 8);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n  // end\n    if (ex > 0) {\n      uxi -= 1 << 23;\n      uxi |= <u32>ex << 23;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f32>(uxi);\n    y = builtin_abs<f32>(y);\n    var x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // q++;\n    }\n    return sx ? -x : x;\n  }\n\n  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c\n    const s1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // 1 * M_PI_2\n    const s2pio2 = reinterpret<f64>(0x400921FB54442D18); // 2 * M_PI_2\n    const s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // 3 * M_PI_2\n    const s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  /* |x| ~<= π/4 */\n      if (ix < 0x39800000) { /* |x| < 2**-12 */\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kernf(x);\n      sincos_cos = cos_kernf(x);\n      return;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {   /* |x| ~<= 5π/4 */\n        if (ix <= 0x4016CBE3) { /* |x| ~<= 3π/4 */\n          if (sign) {\n            sincos_sin = -cos_kernf(x + s1pio2);\n            sincos_cos =  sin_kernf(x + s1pio2);\n          } else {\n            sincos_sin = cos_kernf(s1pio2 - x);\n            sincos_cos = sin_kernf(s1pio2 - x);\n          }\n          return;\n        }\n        /* -sin(x + c) is not correct if x+c could be 0: -0 vs +0 */\n        sincos_sin = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);\n        sincos_cos = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);\n        return;\n      }\n      if (ix <= 0x40E231D5) {   /* |x| ~<= 9π/4 */\n        if (ix <= 0x40AFEDDF) { /* |x| ~<= 7π/4 */\n          if (sign) {\n            sincos_sin =  cos_kernf(x + s3pio2);\n            sincos_cos = -sin_kernf(x + s3pio2);\n          } else {\n            sincos_sin = -cos_kernf(x - s3pio2);\n            sincos_cos =  sin_kernf(x - s3pio2);\n          }\n          return;\n        }\n        sincos_sin = sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n        sincos_cos = cos_kernf(sign ? x + s4pio2 : x - s4pio2);\n        return;\n      }\n    }\n    /* sin(Inf or NaN) is NaN */\n    if (ix >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    /* general argument reduction needed */\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n    var s = sin_kernf(y);\n    var c = cos_kernf(y);\n    var sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\nexport function ipow32(x: i32, e: i32): i32 {\n  var out = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (e < 0) return 0;\n\n    switch (e) {\n      case 0: return 1;\n      case 1: return x;\n      case 2: return x * x;\n    }\n\n    let log = 32 - clz(e);\n    if (log <= 5) {\n      // 32 = 2 ^ 5, so need only five cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 5: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n\n  while (e > 0) {\n    if (e & 1) out *= x;\n    e >>= 1;\n    x *= x;\n  }\n  return out;\n}\n\nexport function ipow64(x: i64, e: i32): i64 {\n  var out: i64 = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (e < 0) return 0;\n    switch (e) {\n      case 0: return 1;\n      case 1: return x;\n      case 2: return x * x;\n    }\n\n    let log = 32 - clz(e);\n    if (log <= 6) {\n      // 64 = 2 ^ 6, so need only six cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 6: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 5: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n\n  while (e > 0) {\n    if (e & 1) out *= x;\n    e >>= 1;\n    x *= x;\n  }\n  return out;\n}\n\nexport function ipow32f(x: f32, e: i32): f32 {\n  var sign = e >> 31;\n  e = (e + sign) ^ sign; // abs(e)\n  var out: f32 = 1;\n  while (e) {\n    out *= select<f32>(x, 1.0, e & 1);\n    e >>= 1;\n    x *= x;\n  }\n  return sign ? <f32>1.0 / out : out;\n}\n\nexport function ipow64f(x: f64, e: i32): f64 {\n  var sign = e >> 31;\n  e = (e + sign) ^ sign; // abs(e)\n  var out = 1.0;\n  while (e) {\n    out *= select(x, 1.0, e & 1);\n    e >>= 1;\n    x *= x;\n  }\n  return sign ? 1.0 / out : out;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { ArrayBufferView } from \"./arraybuffer\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureSize(array: usize, minSize: usize, alignLog2: u32): void {\n  var oldCapacity = changetype<ArrayBufferView>(array).byteLength;\n  if (minSize > <usize>oldCapacity >>> alignLog2) {\n    if (minSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\n    let newCapacity = minSize << alignLog2;\n    let newData = __realloc(oldData, newCapacity);\n    memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    if (newData !== oldData) { // oldData has been free'd\n      store<usize>(array, __retain(newData), offsetof<ArrayBufferView>(\"buffer\"));\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\n    }\n    store<u32>(array, newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\n  }\n}\n\nexport class Array<T> extends ArrayBufferView {\n  [key: number]: T;\n\n  // Implementing ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `data`) and `dataLength` (equals computed `data.byteLength`).\n\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return builtin_isArray(value) && value !== null;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\n    var array = new Array<T>(capacity);\n    array.length = 0;\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    super(length, alignof<T>());\n    this.length_ = length;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    var oldLength = this.length_;\n    if (isManaged<T>()) {\n      if (oldLength > newLength) { // release no longer used refs\n        let dataStart = this.dataStart;\n        let cur = dataStart + (<usize>newLength << alignof<T>());\n        let end = dataStart + (<usize>oldLength << alignof<T>());\n        do __release(load<usize>(cur));\n        while ((cur += sizeof<T>()) < end);\n      } else {\n        ensureSize(changetype<usize>(this), newLength, alignof<T>());\n      }\n    } else {\n      ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    }\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (!fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(predicate: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (predicate(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return index;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = this.__unchecked_get(index);\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __unchecked_get(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    ensureSize(changetype<usize>(this), index + 1, alignof<T>());\n    this.__unchecked_set(index, value);\n    if (index >= this.length_) this.length_ = index + 1;\n  }\n\n  @unsafe @operator(\"{}=\") private __unchecked_set(index: i32, value: T): void {\n    if (isManaged<T>()) {\n      let offset = this.dataStart + (<usize>index << alignof<T>());\n      let oldRef = load<usize>(offset);\n      if (changetype<usize>(value) != oldRef) {\n        store<usize>(offset, __retain(changetype<usize>(value)));\n        __release(oldRef);\n      }\n    } else {\n      store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    }\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var dataStart = this.dataStart;\n    var length = this.length_;\n    start = start < 0 ? max(length + start, 0) : min(start, length);\n    end   = end   < 0 ? max(length + end,   0) : min(end,   length);\n    if (isManaged<T>()) {\n      for (; start < end; ++start) {\n        let oldRef: usize = load<usize>(dataStart + (<usize>start << alignof<T>()));\n        if (changetype<usize>(value) != oldRef) {\n          store<usize>(dataStart + (<usize>start << alignof<T>()), __retain(changetype<usize>(value)));\n          __release(oldRef);\n        }\n      }\n    } else if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          dataStart + <usize>start,\n          u8(value),\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        store<T>(dataStart + (<usize>start << alignof<T>()), value);\n      }\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length_;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      let dataStart = this.dataStart;\n      while (fromIndex < length) {\n        let elem = load<T>(dataStart + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    var length = this.length_;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    var dataStart = this.dataStart;\n    while (fromIndex < length) {\n      if (load<T>(dataStart + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    var length = this.length_;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    var dataStart = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(dataStart + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    var length = this.length_;\n    var newLength = length + 1;\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>length << alignof<T>()), __retain(changetype<usize>(value)));\n    } else {\n      store<T>(this.dataStart + (<usize>length << alignof<T>()), value);\n    }\n    this.length_ = newLength;\n    return newLength;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    var thisLen = this.length_;\n    var otherLen = select(0, other.length_, other === null);\n    var outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<Array<T>>(__allocArray(outLen, alignof<T>(), idof<Array<T>>())); // retains\n    var outStart = out.dataStart;\n    var thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, __retain(ref));\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, __retain(ref));\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var dataStart = this.dataStart;\n    var len = this.length_;\n\n        end   = min<i32>(end, len);\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    if (isManaged<T>()) {\n      if (from < to && to < (from + count)) { // right to left\n        from += count - 1;\n        to   += count - 1;\n        while (count) {\n          let oldRef: usize = load<usize>(dataStart + (<usize>to << alignof<T>()));\n          let newRef: usize = load<usize>(dataStart + (<usize>from << alignof<T>()));\n          if (newRef != oldRef) {\n            store<usize>(dataStart + (<usize>to << alignof<T>()), __retain(newRef));\n            __release(oldRef);\n          }\n          --from, --to, --count;\n        }\n      } else { // left to right\n        while (count) {\n          let oldRef: usize = load<usize>(dataStart + (<usize>to << alignof<T>()));\n          let newRef: usize = load<usize>(dataStart + (<usize>from << alignof<T>()));\n          if (newRef != oldRef) {\n            store<usize>(dataStart + (<usize>to << alignof<T>()), __retain(newRef));\n            __release(oldRef);\n          }\n          ++from, ++to, --count;\n        }\n      }\n    } else {\n      memory.copy( // is memmove\n        dataStart + (<usize>to << alignof<T>()),\n        dataStart + (<usize>from << alignof<T>()),\n        <usize>count << alignof<T>()\n      );\n    }\n    return this;\n  }\n\n  pop(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(E_EMPTYARRAY);\n    var element = load<T>(this.dataStart + (<usize>(--length) << alignof<T>()));\n    this.length_ = length;\n    return element; // no need to retain -> is moved\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    var length = this.length_;\n    var out = changetype<Array<U>>(__allocArray(length, alignof<U>(), idof<Array<U>>())); // retains\n    var outStart = out.dataStart;\n    for (let index = 0; index < min(length, this.length_); ++index) {\n      let result = fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this); // retains\n      if (isManaged<U>()) {\n        store<usize>(outStart + (<usize>index << alignof<U>()), __retain(changetype<usize>(result)));\n      } else {\n        store<U>(outStart + (<usize>index << alignof<U>()), result);\n      }\n      // releases result\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    var result = changetype<Array<T>>(__allocArray(0, alignof<T>(), idof<Array<T>>())); // retains\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n      if (fn(value, index, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      accum = fn(accum, load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n    return accum;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = this.length_ - 1; index >= 0; --index) {\n      accum = fn(accum, load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n    return accum;\n  }\n\n  shift(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(E_EMPTYARRAY);\n    var base = this.dataStart;\n    var element = load<T>(base);\n    var lastIndex = length - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    store<T>(base + (<usize>lastIndex << alignof<T>()),\n      // @ts-ignore: cast\n      <T>null\n    );\n    this.length_ = lastIndex;\n    return element; // no need to retain -> is moved\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    var newLength = this.length_ + 1;\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    var dataStart = this.dataStart;\n    memory.copy(\n      dataStart + sizeof<T>(),\n      dataStart,\n      <usize>(newLength - 1) << alignof<T>()\n    );\n    if (isManaged<T>()) {\n      store<usize>(dataStart, __retain(changetype<usize>(value)));\n    } else {\n      store<T>(dataStart, value);\n    }\n    this.length_ = newLength;\n    return newLength;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var length = this.length_;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\n    length = max(end - start, 0);\n    var slice = changetype<Array<T>>(__allocArray(length, alignof<T>(), idof<Array<T>>())); // retains\n    var sliceBase = slice.dataStart;\n    var thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>length << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, __retain(ref));\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, length << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    var length  = this.length_;\n    start       = start < 0 ? max<i32>(length + start, 0) : min<i32>(start, length);\n    deleteCount = max<i32>(min<i32>(deleteCount, length - start), 0);\n    var result = changetype<Array<T>>(__allocArray(deleteCount, alignof<T>(), idof<Array<T>>())); // retains\n    var resultStart = result.dataStart;\n    var thisStart = this.dataStart;\n    var thisBase  = thisStart + (<usize>start << alignof<T>());\n    // no need to retain -> is moved\n    memory.copy(\n      resultStart,\n      thisBase,\n      <usize>deleteCount << alignof<T>()\n    );\n    var offset = start + deleteCount;\n    if (length != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(length - offset) << alignof<T>()\n      );\n    }\n    this.length_ = length - deleteCount;\n    return result;\n  }\n\n  reverse(): Array<T> {\n    var length = this.length_;\n    if (length) {\n      let front = this.dataStart;\n      let back = this.dataStart + (<usize>(length - 1) << alignof<T>());\n      while (front < back) {\n        let temp = load<T>(front);\n        store<T>(front, load<T>(back));\n        store<T>(back, temp);\n        front += sizeof<T>();\n        back -= sizeof<T>();\n      }\n    }\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    var length = this.length_;\n    if (length <= 1) return this;\n    var base = this.dataStart;\n    if (length == 2) {\n      let a: T = load<T>(base, sizeof<T>()); // a = arr[1]\n      let b: T = load<T>(base); // b = arr[0]\n      if (comparator(a, b) < 0) {\n        store<T>(base, b, sizeof<T>()); // arr[1] = b;\n        store<T>(base, a); // arr[0] = a;\n      }\n      return this;\n    }\n    SORT<T>(base, length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    var dataStart = this.dataStart;\n    var length = this.length_;\n    if (isBoolean<T>())   return joinBooleanArray(dataStart, length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(dataStart, length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(dataStart, length, separator);\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(dataStart, length, separator);\n    }\n    // For rest objects and arrays use general join routine\n    if (isReference<T>()) return joinReferenceArray<T>(dataStart, length, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit_impl(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    // automatically visits ArrayBufferView (.buffer) next\n  }\n}\n"]}